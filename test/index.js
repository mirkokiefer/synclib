// Generated by CoffeeScript 1.3.3
(function() {
  var Repository, assert, assertArray, assertPathData, async, commitB, commitC, commitD, contains, dataA, dataAHashes, dataB, dataBHashes, dataC, dataD, difference, each, keys, pairs, pluck, repo, testBranchA, testBranchB, testBranchC, testBranchD, testCommitAncestors, testData, union, values, where, _, _ref,
    __slice = [].slice;

  assert = require('assert');

  Repository = require('../lib/index').Repository;

  async = require('async');

  _ = require('underscore');

  union = _.union, difference = _.difference, keys = _.keys, values = _.values, pluck = _.pluck, contains = _.contains, where = _.where, pairs = _.pairs;

  repo = new Repository();

  _ref = (function() {
    var _i, _len, _ref, _results;
    _ref = ['a', 'b', 'c', 'd'];
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      each = _ref[_i];
      _results.push(repo.branch());
    }
    return _results;
  })(), testBranchA = _ref[0], testBranchB = _ref[1], testBranchC = _ref[2], testBranchD = _ref[3];

  assertArray = function(array, expectedArray) {
    var _i, _j, _len, _len1, _results;
    for (_i = 0, _len = expectedArray.length; _i < _len; _i++) {
      each = expectedArray[_i];
      assert.ok(contains(array, each));
    }
    _results = [];
    for (_j = 0, _len1 = array.length; _j < _len1; _j++) {
      each = array[_j];
      _results.push(assert.ok(contains(expectedArray, each)));
    }
    return _results;
  };

  assertPathData = function(data, expected) {
    var found, path, value, _i, _len, _ref1, _results;
    assert.equal(data.length, expected.length);
    _results = [];
    for (_i = 0, _len = expected.length; _i < _len; _i++) {
      _ref1 = expected[_i], path = _ref1.path, value = _ref1.value;
      found = where(data, {
        path: path
      });
      assert.equal(found.length, 1);
      _results.push(assert.equal(found[0].value, value));
    }
    return _results;
  };

  testData = function(branch, data, cb) {
    var forEach;
    forEach = function(_arg, cb) {
      var expectedValue, path;
      path = _arg[0], expectedValue = _arg[1];
      return branch.dataAtPath(path, function(err, value) {
        assert.equal(value, expectedValue);
        return cb();
      });
    };
    return async.forEach(pairs(data), forEach, cb);
  };

  testCommitAncestors = function(commitHash, hashs, cb) {
    var first, rest;
    first = hashs[0], rest = 2 <= hashs.length ? __slice.call(hashs, 1) : [];
    assert.equal(commitHash, first);
    if (rest.length > 0) {
      return repo._commitStore.read(commitHash, function(err, _arg) {
        var ancestors;
        ancestors = _arg.ancestors;
        return testCommitAncestors(ancestors[0], rest, cb);
      });
    }
  };

  dataA = [
    {
      'a': "hashA 0.0",
      'b/c': "hashA 0.1",
      'b/d': "hashA 0.2"
    }, {
      'a': "hashA 1.0",
      'b/c': "hashA 1.1",
      'b/e': "hashA 1.2",
      'b/f/g': "hashA 1.3"
    }, {
      'b/e': "hashA 2.0"
    }
  ];

  dataB = [
    {
      'b/h': "hashB 0.0"
    }, {
      'c/a': "hashB 1.0"
    }, {
      'a': "hashB 2.0",
      'u': "hashB 2.1"
    }, {
      'b/c': "hashB 3.0",
      'b/e': "hashB 3.1",
      'b/f/a': "hashB 3.2"
    }
  ];

  dataC = [
    {
      'a': 'hashC 0.0',
      'c/a': 'hashC 0.1'
    }, {
      'a': 'hashC 1.0'
    }
  ];

  dataD = [
    {
      'e': 'hashD 0.0'
    }, {
      'b/f/b': 'hashD 1.0'
    }
  ];

  dataAHashes = ['b2ef9fc4cb736db036b5dc098f1054546bcaf1be', '5bc500f2e12c1cf10719925cf1848413965603ff', '7693e2f18011f0a995e26880f17230fd36f04c5d'];

  dataBHashes = ['fca94cfa923725e3c6318bb5eef14dffd9c38091', 'ae1287e2835cfea8fca7a880dcfe09ecf4dfb428', 'c3015798e734dc9bbc3e8fc58e677e2eacc1a377', '68d1f53596baa4bdc69208a06538e88d9612e77a'];

  commitB = {
    data: dataB,
    ref: dataAHashes[1],
    branch: testBranchB
  };

  commitC = {
    data: dataC,
    branch: testBranchC
  };

  commitD = {
    data: dataD,
    ref: dataBHashes[1],
    branch: testBranchD
  };

  /*
  a graphical branch view:
  
                           d0 - d1 <- D
                         /
            b0 - b1 - b2 - b3 <- B
          /
  a0 - a1 - a2 <- A
  
  c0 - c1 <- C
  */


  describe('branch', function() {
    describe('commit', function() {
      it('should commit and read objects', function(done) {
        return testBranchA.commit(dataA[0], function(err, head) {
          assert.equal(head, dataAHashes[0]);
          return testData(testBranchA, dataA[0], done);
        });
      });
      it('should create a child commit', function(done) {
        return testBranchA.commit(dataA[1], function(err, head) {
          assert.equal(head, dataAHashes[1]);
          return testData(testBranchA, dataA[1], function() {
            return testBranchA.dataAtPath('b/d', function(err, d) {
              assert.equal(d, dataA[0]['b/d']);
              return done();
            });
          });
        });
      });
      it('should not create a new commit', function(done) {
        var oldHead;
        oldHead = testBranchA.head;
        return testBranchA.commit(dataA[1], function(err, head) {
          assert.equal(head, oldHead);
          return done();
        });
      });
      it('should read from a previous commit', function(done) {
        var head1;
        head1 = testBranchA.head;
        return testBranchA.commit(dataA[2], function(err, head2) {
          assert.equal(head2, dataAHashes[2]);
          return repo.dataAtPath(head1, 'b/e', function(err, eHead1) {
            assert.equal(eHead1, dataA[1]['b/e']);
            return repo.dataAtPath(head2, 'b/e', function(err, eHead2) {
              assert.equal(eHead2, dataA[2]['b/e']);
              return done();
            });
          });
        });
      });
      return it('should populate more test branches', function(done) {
        var commitData;
        commitData = function(_arg, cb) {
          var branch, data, ref;
          branch = _arg.branch, data = _arg.data, ref = _arg.ref;
          branch.head = ref;
          return async.forEach(data, (function(each, cb) {
            return branch.commit(each, cb);
          }), cb);
        };
        return async.forEach([commitB, commitC, commitD], commitData, function() {
          testCommitAncestors(testBranchB.head, dataBHashes);
          return done();
        });
      });
    });
    describe('commonCommit', function() {
      it('should find a common commit', function(done) {
        var tests;
        tests = [
          function(cb) {
            return testBranchA.commonCommit(testBranchB, cb);
          }, function(cb) {
            return testBranchA.commonCommit(testBranchD, cb);
          }, function(cb) {
            return testBranchA.commonCommit(dataAHashes[0], cb);
          }, function(cb) {
            return repo.commonCommit(dataAHashes[2], dataAHashes[0], cb);
          }, function(cb) {
            return repo.commonCommit(dataAHashes[0], dataAHashes[2], cb);
          }
        ];
        return async.series(tests, function(err, results) {
          var expectedResults, i, _i, _len;
          expectedResults = [dataAHashes[1], dataAHashes[1], dataAHashes[0], dataAHashes[0], dataAHashes[0]];
          for (i = _i = 0, _len = expectedResults.length; _i < _len; i = ++_i) {
            each = expectedResults[i];
            assert.equal(results[i], each);
          }
          return done();
        });
      });
      it('should find a common commit with paths', function(done) {
        return testBranchA.commonCommitWithPaths(testBranchB, function(err, res1) {
          var expectedCommit1Path, expectedCommit2Path;
          expectedCommit1Path = [dataAHashes[1], dataAHashes[2]];
          expectedCommit2Path = dataBHashes.concat(dataAHashes[1]);
          assertArray(res1.commit1Path, expectedCommit1Path);
          assertArray(res1.commit2Path, expectedCommit2Path);
          return testBranchA.commonCommitWithPaths(dataAHashes[0], function(err, res2) {
            assert.equal(res2.commit2Path.length, 1);
            return done();
          });
        });
      });
      return it('should not find a common commit', function(done) {
        return testBranchA.commonCommit(testBranchC, function(err, res) {
          assert.equal(res, void 0);
          return done();
        });
      });
    });
    describe('diff', function() {
      it('should find the diff between two commits', function(done) {
        return repo.diff(dataAHashes[0], dataAHashes[1], function(err, diff) {
          var path, value, _i, _len, _ref1, _ref2;
          assert.equal(diff.values.length, _.keys(dataA[1]).length);
          _ref1 = diff.values;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            _ref2 = _ref1[_i], path = _ref2.path, value = _ref2.value;
            assert.equal(value, dataA[1][path]);
          }
          assert.equal(diff.trees.length, 3);
          return done();
        });
      });
      it('should find the diff between null and a commit', function(done) {
        return repo.diff(null, dataAHashes[0], function(err, diff) {
          var path, value, _i, _len, _ref1, _ref2;
          _ref1 = diff.values;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            _ref2 = _ref1[_i], path = _ref2.path, value = _ref2.value;
            assert.equal(value, dataA[0][path]);
          }
          return done();
        });
      });
      return it('should find the diff between the current head and another commit', function(done) {
        return testBranchA.diff(testBranchB, function(err, diff) {
          assert.ok(diff);
          return done();
        });
      });
    });
    describe('deltaHashs', function() {
      it('should find the diff as hashes between heads in the past and the current head', function(done) {
        return testBranchA.deltaHashs({
          from: [dataAHashes[0]]
        }, function(err, diff) {
          var realDataHashs;
          realDataHashs = _.union(_.values(dataA[1]), _.values(dataA[2]));
          assertArray(diff.values, realDataHashs);
          return done();
        });
      });
      it('should find the diff between a head in the past that doesnt exist and the current head', function(done) {
        return testBranchA.deltaHashs({
          from: ['non-existing']
        }, function(err, diff) {
          var realDataHashs;
          realDataHashs = _.union(_.values(dataA[0]), _.values(dataA[1]), _.values(dataA[2]));
          assertArray(diff.values, realDataHashs);
          return done();
        });
      });
      it('should work without a ref - returns the full diff', function(done) {
        return testBranchA.deltaHashs({}, function(err, diff) {
          var realDataHashs;
          realDataHashs = _.union(_.values(dataA[0]), _.values(dataA[1]), _.values(dataA[2]));
          assertArray(diff.values, realDataHashs);
          return done();
        });
      });
      it('should compute the value to a disconnected branch', function(done) {
        return testBranchA.deltaHashs({
          to: [testBranchC]
        }, function(err, diff) {
          var realDataHashs;
          realDataHashs = _.union(_.values(dataC[0]), _.values(dataC[1]));
          assertArray(diff.values, realDataHashs);
          return done();
        });
      });
      it('should compute the value from a single commit to multiple commits', function(done) {
        return testBranchD.deltaHashs({
          to: [testBranchA, testBranchB]
        }, function(err, diff) {
          var realDataHashs;
          realDataHashs = _.union(_.values(dataA[2]), _.values(dataB[3]));
          assertArray(diff.values, realDataHashs);
          return done();
        });
      });
      return it('should compute the delta from multiple commits to a single commit', function(done) {
        return testBranchD.deltaHashs({
          from: [testBranchA, testBranchB, testBranchC]
        }, function(err, diff) {
          var realDataHashs;
          realDataHashs = union(values(dataD[0]), values(dataD[1]));
          assertArray(diff.values, realDataHashs);
          return done();
        });
      });
    });
    return describe('delta', function() {
      return it('should find the diff including the actual trees and commits', function(done) {
        return testBranchA.deltaHashs({
          from: [dataAHashes[0]]
        }, function(err, diffHashs) {
          return repo.deltaData(diffHashs, function(err, diff) {
            assert.equal(diff.trees.length, 5);
            assert.ok(diff.trees[0].length > 40);
            assert.ok(diff.commits[0].length > 40);
            return done();
          });
        });
      });
    });
    /*describe 'merge', () ->
      assertMerge = (branch, expectedData, expectedHeads) ->
        head = repo._commitStore.read branch.head
        assertArray head.ancestors, expectedHeads
        assertPathData branch.allPaths(), expectedData
      it 'should merge branchB into branchA', () ->
        expectedData = [
          { path: 'b/f/a', value: 'hashB 3.2' },
          { path: 'b/f/g', value: 'hashA 1.3' },
          { path: 'b/c', value: 'hashB 3.0' },
          { path: 'b/d', value: 'hashA 0.2' },
          { path: 'b/e', value: 'hashB 3.1' },
          { path: 'b/h', value: 'hashB 0.0' },
          { path: 'c/a', value: 'hashB 1.0' },
          { path: 'a', value: 'hashB 2.0' },
          { path: 'u', value: 'hashB 2.1' }
        ]
        oldHead = testBranchA.head
        strategy = (path, value1Hash, value2Hash) -> value2Hash
        testBranchA.merge ref: testBranchB, strategy: strategy
        assertMerge testBranchA, expectedData, [oldHead, testBranchB.head]
      it 'should merge branchA into branchB', () ->
        expectedData = [
          { path: 'b/f/a', value: 'hashB 3.2' },
          { path: 'b/f/g', value: 'hashA 1.3' },
          { path: 'b/c', value: 'hashB 3.0' },
          { path: 'b/d', value: 'hashA 0.2' },
          { path: 'b/e', value: 'hashB 3.1' },
          { path: 'b/h', value: 'hashB 0.0' },
          { path: 'c/a', value: 'hashB 1.0' },
          { path: 'a', value: 'hashB 2.0' },
          { path: 'u', value: 'hashB 2.1' }
        ]
        oldHead = testBranchB.head
        testBranchB.merge ref: dataAHashes[2]
        assertMerge testBranchB, expectedData, [oldHead, dataAHashes[2]]
        assert.equal testBranchB.head, testBranchA.head
      it 'should merge branchA into branchC (they do not have a common commit)', () ->
        expectedData = [
          { path: 'b/f/g', value: 'hashA 1.3' },
          { path: 'b/c', value: 'hashA 1.1' },
          { path: 'b/d', value: 'hashA 0.2' },
          { path: 'b/e', value: 'hashA 2.0' },
          { path: 'c/a', value: 'hashC 0.1' },
          { path: 'a', value: 'hashC 1.0' }
        ]
        oldHeadC = testBranchC.head
        testBranchC.merge ref: dataAHashes[2]
        assertMerge testBranchC, expectedData, [oldHeadC, dataAHashes[2]]
    describe 'commit deletes', ->
      it 'should delete data', ->
        data = {'b/c': null, 'b/f/a': null, 'b/f/g': null, 'a': 1}
        testBranchB.commit data, ->
          testData testBranchB, data
    describe 'treeAtPath', ->
      it 'should read the root tree', ->
        tree = testBranchA.treeAtPath ''
        assert.ok tree.childData
      it 'should read a child tree', ->
        tree = testBranchA.treeAtPath 'b/f'
        assert.equal tree.childData.g, dataA[1]['b/f/g']
    describe 'paths', ->
      it 'should return all tracked paths', ->
        testBranch = repo.branch dataAHashes[0]
        expectedPaths = keys dataA[0]
        paths = pluck testBranch.allPaths(), 'path'
        assert.equal difference(paths, expectedPaths).length, 0
        assert.equal difference(expectedPaths, paths).length, 0
    */

  });

}).call(this);
