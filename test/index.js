// Generated by CoffeeScript 1.3.3
(function() {
  var Repository, assert, assertArray, assertPathData, async, commitB, commitC, commitD, contains, dataA, dataAHashes, dataB, dataBHashes, dataC, dataD, difference, each, keys, pairs, pluck, repo, testBranchA, testBranchB, testBranchC, testBranchD, testCommitAncestors, testData, union, values, where, _, _ref,
    __slice = [].slice;

  assert = require('assert');

  Repository = require('../lib/index').Repository;

  async = require('async');

  _ = require('underscore');

  union = _.union, difference = _.difference, keys = _.keys, values = _.values, pluck = _.pluck, contains = _.contains, where = _.where, pairs = _.pairs;

  repo = new Repository();

  _ref = (function() {
    var _i, _len, _ref, _results;
    _ref = ['a', 'b', 'c', 'd'];
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      each = _ref[_i];
      _results.push(repo.branch());
    }
    return _results;
  })(), testBranchA = _ref[0], testBranchB = _ref[1], testBranchC = _ref[2], testBranchD = _ref[3];

  assertArray = function(array, expectedArray) {
    var _i, _j, _len, _len1, _results;
    for (_i = 0, _len = expectedArray.length; _i < _len; _i++) {
      each = expectedArray[_i];
      assert.ok(contains(array, each));
    }
    _results = [];
    for (_j = 0, _len1 = array.length; _j < _len1; _j++) {
      each = array[_j];
      _results.push(assert.ok(contains(expectedArray, each)));
    }
    return _results;
  };

  assertPathData = function(data, expected) {
    var found, path, value, _i, _len, _ref1, _results;
    assert.equal(data.length, expected.length);
    _results = [];
    for (_i = 0, _len = expected.length; _i < _len; _i++) {
      _ref1 = expected[_i], path = _ref1.path, value = _ref1.value;
      found = where(data, {
        path: path
      });
      assert.equal(found.length, 1);
      _results.push(assert.equal(found[0].value, value));
    }
    return _results;
  };

  testData = function(branch, data, cb) {
    var forEach;
    forEach = function(_arg, cb) {
      var expectedValue, path;
      path = _arg[0], expectedValue = _arg[1];
      return branch.dataAtPath(path, function(err, value) {
        assert.equal(value, expectedValue);
        return cb();
      });
    };
    return async.forEach(pairs(data), forEach, cb);
  };

  testCommitAncestors = function(commitHash, hashs, cb) {
    var first, rest;
    first = hashs[0], rest = 2 <= hashs.length ? __slice.call(hashs, 1) : [];
    assert.equal(commitHash, first);
    if (rest.length > 0) {
      return repo._commitStore.read(commitHash, function(err, _arg) {
        var ancestors;
        ancestors = _arg.ancestors;
        return testCommitAncestors(ancestors[0], rest, cb);
      });
    }
  };

  dataA = [
    {
      'a': "hashA 0.0",
      'b/c': "hashA 0.1",
      'b/d': "hashA 0.2"
    }, {
      'a': "hashA 1.0",
      'b/c': "hashA 1.1",
      'b/e': "hashA 1.2",
      'b/f/g': "hashA 1.3"
    }, {
      'b/e': "hashA 2.0"
    }
  ];

  dataB = [
    {
      'b/h': "hashB 0.0"
    }, {
      'c/a': "hashB 1.0"
    }, {
      'a': "hashB 2.0",
      'u': "hashB 2.1"
    }, {
      'b/c': "hashB 3.0",
      'b/e': "hashB 3.1",
      'b/f/a': "hashB 3.2"
    }
  ];

  dataC = [
    {
      'a': 'hashC 0.0',
      'c/a': 'hashC 0.1'
    }, {
      'a': 'hashC 1.0'
    }
  ];

  dataD = [
    {
      'e': 'hashD 0.0'
    }, {
      'b/f/b': 'hashD 1.0'
    }
  ];

  dataAHashes = ['b2ef9fc4cb736db036b5dc098f1054546bcaf1be', '5bc500f2e12c1cf10719925cf1848413965603ff', '7693e2f18011f0a995e26880f17230fd36f04c5d'];

  dataBHashes = ['fca94cfa923725e3c6318bb5eef14dffd9c38091', 'ae1287e2835cfea8fca7a880dcfe09ecf4dfb428', 'c3015798e734dc9bbc3e8fc58e677e2eacc1a377', '68d1f53596baa4bdc69208a06538e88d9612e77a'];

  commitB = {
    data: dataB,
    ref: dataAHashes[1],
    branch: testBranchB
  };

  commitC = {
    data: dataC,
    branch: testBranchC
  };

  commitD = {
    data: dataD,
    ref: dataBHashes[1],
    branch: testBranchD
  };

  /*
  a graphical branch view:
  
                           d0 - d1 <- D
                         /
            b0 - b1 - b2 - b3 <- B
          /
  a0 - a1 - a2 <- A
  
  c0 - c1 <- C
  */


  describe('branch', function() {
    describe('commit', function() {
      it('should commit and read objects', function(done) {
        return testBranchA.commit(dataA[0], function(err, head) {
          assert.equal(head, dataAHashes[0]);
          return testData(testBranchA, dataA[0], done);
        });
      });
      it('should create a child commit', function(done) {
        return testBranchA.commit(dataA[1], function(err, head) {
          assert.equal(head, dataAHashes[1]);
          return testData(testBranchA, dataA[1], function() {
            return testBranchA.dataAtPath('b/d', function(err, d) {
              assert.equal(d, dataA[0]['b/d']);
              return done();
            });
          });
        });
      });
      it('should not create a new commit', function(done) {
        var oldHead;
        oldHead = testBranchA.head;
        return testBranchA.commit(dataA[1], function(err, head) {
          assert.equal(head, oldHead);
          return done();
        });
      });
      it('should read from a previous commit', function(done) {
        var head1;
        head1 = testBranchA.head;
        return testBranchA.commit(dataA[2], function(err, head2) {
          assert.equal(head2, dataAHashes[2]);
          return repo.dataAtPath(head1, 'b/e', function(err, eHead1) {
            assert.equal(eHead1, dataA[1]['b/e']);
            return repo.dataAtPath(head2, 'b/e', function(err, eHead2) {
              assert.equal(eHead2, dataA[2]['b/e']);
              return done();
            });
          });
        });
      });
      return it('should populate more test branches', function(done) {
        var commitData;
        commitData = function(_arg, cb) {
          var branch, data, ref;
          branch = _arg.branch, data = _arg.data, ref = _arg.ref;
          branch.head = ref;
          return async.forEach(data, (function(each, cb) {
            return branch.commit(each, cb);
          }), cb);
        };
        return async.forEach([commitB, commitC, commitD], commitData, function() {
          testCommitAncestors(testBranchB.head, dataBHashes);
          return done();
        });
      });
    });
    describe('commonCommit', function() {
      it('should find a common commit', function(done) {
        var tests;
        tests = [
          function(cb) {
            return testBranchA.commonCommit(testBranchB, cb);
          }, function(cb) {
            return testBranchA.commonCommit(testBranchD, cb);
          }, function(cb) {
            return testBranchA.commonCommit(dataAHashes[0], cb);
          }, function(cb) {
            return repo.commonCommit(dataAHashes[2], dataAHashes[0], cb);
          }, function(cb) {
            return repo.commonCommit(dataAHashes[0], dataAHashes[2], cb);
          }
        ];
        return async.series(tests, function(err, results) {
          var expectedResults, i, _i, _len;
          expectedResults = [dataAHashes[1], dataAHashes[1], dataAHashes[0], dataAHashes[0], dataAHashes[0]];
          for (i = _i = 0, _len = expectedResults.length; _i < _len; i = ++_i) {
            each = expectedResults[i];
            assert.equal(results[i], each);
          }
          return done();
        });
      });
      it('should find a common commit with paths', function(done) {
        return testBranchA.commonCommitWithPaths(testBranchB, function(err, res1) {
          var expectedCommit1Path, expectedCommit2Path;
          expectedCommit1Path = [dataAHashes[1], dataAHashes[2]];
          expectedCommit2Path = dataBHashes.concat(dataAHashes[1]);
          assertArray(res1.commit1Path, expectedCommit1Path);
          assertArray(res1.commit2Path, expectedCommit2Path);
          return testBranchA.commonCommitWithPaths(dataAHashes[0], function(err, res2) {
            assert.equal(res2.commit2Path.length, 1);
            return done();
          });
        });
      });
      return it('should not find a common commit', function(done) {
        return testBranchA.commonCommit(testBranchC, function(err, res) {
          assert.equal(res, void 0);
          return done();
        });
      });
    });
    describe('diff', function() {
      it('should find the diff between two commits', function(done) {
        return repo.diff(dataAHashes[0], dataAHashes[1], function(err, diff) {
          var path, value, _i, _len, _ref1, _ref2;
          assert.equal(diff.values.length, _.keys(dataA[1]).length);
          _ref1 = diff.values;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            _ref2 = _ref1[_i], path = _ref2.path, value = _ref2.value;
            assert.equal(value, dataA[1][path]);
          }
          assert.equal(diff.trees.length, 3);
          return done();
        });
      });
      it('should find the diff between null and a commit', function(done) {
        return repo.diff(null, dataAHashes[0], function(err, diff) {
          var path, value, _i, _len, _ref1, _ref2;
          _ref1 = diff.values;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            _ref2 = _ref1[_i], path = _ref2.path, value = _ref2.value;
            assert.equal(value, dataA[0][path]);
          }
          return done();
        });
      });
      return it('should find the diff between the current head and another commit', function(done) {
        return testBranchA.diff(testBranchB, function(err, diff) {
          assert.ok(diff);
          return done();
        });
      });
    });
    describe('delta', function() {
      it('should find the diff as hashes between heads in the past and the current head', function(done) {
        return testBranchA.delta({
          from: [dataAHashes[0]]
        }, function(err, diff) {
          var expectedSerialized, realDataHashs;
          realDataHashs = _.union(_.values(dataA[1]), _.values(dataA[2]));
          assertArray(diff.values, realDataHashs);
          assertArray(pluck(diff.commits, 'hash'), [dataAHashes[1], dataAHashes[2]]);
          expectedSerialized = ['[["5bc500f2e12c1cf10719925cf1848413965603ff"],"61b4e5cba3e16752ce4d9b30cc1509ff62890293",[]]', '[["b2ef9fc4cb736db036b5dc098f1054546bcaf1be"],"1aebadc7bcec1e477ba1cb9a9a4536b35f398779",[]]'];
          assertArray(pluck(diff.commits, 'data'), expectedSerialized);
          return done();
        });
      });
      it('should find the diff between a head in the past that doesnt exist and the current head', function(done) {
        return testBranchA.delta({
          from: ['non-existing']
        }, function(err, diff) {
          var realDataHashs;
          realDataHashs = _.union(_.values(dataA[0]), _.values(dataA[1]), _.values(dataA[2]));
          assertArray(diff.values, realDataHashs);
          return done();
        });
      });
      it('should work without a ref - returns the full diff', function(done) {
        return testBranchA.delta({}, function(err, diff) {
          var realDataHashs;
          realDataHashs = _.union(_.values(dataA[0]), _.values(dataA[1]), _.values(dataA[2]));
          assertArray(diff.values, realDataHashs);
          return done();
        });
      });
      it('should compute the value to a disconnected branch', function(done) {
        return testBranchA.delta({
          to: [testBranchC]
        }, function(err, diff) {
          var realDataHashs;
          realDataHashs = _.union(_.values(dataC[0]), _.values(dataC[1]));
          assertArray(diff.values, realDataHashs);
          return done();
        });
      });
      it('should compute the value from a single commit to multiple commits', function(done) {
        return testBranchD.delta({
          to: [testBranchA, testBranchB]
        }, function(err, diff) {
          var realDataHashs;
          realDataHashs = _.union(_.values(dataA[2]), _.values(dataB[3]));
          assertArray(diff.values, realDataHashs);
          return done();
        });
      });
      return it('should compute the delta from multiple commits to a single commit', function(done) {
        return testBranchD.delta({
          from: [testBranchA, testBranchB, testBranchC]
        }, function(err, diff) {
          var realDataHashs;
          realDataHashs = union(values(dataD[0]), values(dataD[1]));
          assertArray(diff.values, realDataHashs);
          return done();
        });
      });
    });
    describe('merge', function() {
      var assertMerge;
      assertMerge = function(branch, expectedData, expectedHeads, cb) {
        return repo._commitStore.read(branch.head, function(err, head) {
          assertArray(head.ancestors, expectedHeads);
          return branch.allPaths(function(err, paths) {
            assertPathData(paths, expectedData);
            return cb();
          });
        });
      };
      it('should merge branchB into branchA', function(done) {
        var expectedData, oldHead, strategy;
        expectedData = [
          {
            path: 'b/f/a',
            value: 'hashB 3.2'
          }, {
            path: 'b/f/g',
            value: 'hashA 1.3'
          }, {
            path: 'b/c',
            value: 'hashB 3.0'
          }, {
            path: 'b/d',
            value: 'hashA 0.2'
          }, {
            path: 'b/e',
            value: 'hashB 3.1'
          }, {
            path: 'b/h',
            value: 'hashB 0.0'
          }, {
            path: 'c/a',
            value: 'hashB 1.0'
          }, {
            path: 'a',
            value: 'hashB 2.0'
          }, {
            path: 'u',
            value: 'hashB 2.1'
          }
        ];
        oldHead = testBranchA.head;
        strategy = function(path, value1Hash, value2Hash) {
          return value2Hash;
        };
        return testBranchA.merge({
          ref: testBranchB,
          strategy: strategy
        }, function() {
          return assertMerge(testBranchA, expectedData, [oldHead, testBranchB.head], done);
        });
      });
      it('should merge branchA into branchB', function(done) {
        var expectedData, oldHead;
        expectedData = [
          {
            path: 'b/f/a',
            value: 'hashB 3.2'
          }, {
            path: 'b/f/g',
            value: 'hashA 1.3'
          }, {
            path: 'b/c',
            value: 'hashB 3.0'
          }, {
            path: 'b/d',
            value: 'hashA 0.2'
          }, {
            path: 'b/e',
            value: 'hashB 3.1'
          }, {
            path: 'b/h',
            value: 'hashB 0.0'
          }, {
            path: 'c/a',
            value: 'hashB 1.0'
          }, {
            path: 'a',
            value: 'hashB 2.0'
          }, {
            path: 'u',
            value: 'hashB 2.1'
          }
        ];
        oldHead = testBranchB.head;
        return testBranchB.merge({
          ref: dataAHashes[2]
        }, function() {
          assert.equal(testBranchB.head, testBranchA.head);
          return assertMerge(testBranchB, expectedData, [oldHead, dataAHashes[2]], done);
        });
      });
      it('should merge branchA into branchC (they do not have a common commit)', function(done) {
        var expectedData, oldHeadC;
        expectedData = [
          {
            path: 'b/f/g',
            value: 'hashA 1.3'
          }, {
            path: 'b/c',
            value: 'hashA 1.1'
          }, {
            path: 'b/d',
            value: 'hashA 0.2'
          }, {
            path: 'b/e',
            value: 'hashA 2.0'
          }, {
            path: 'c/a',
            value: 'hashC 0.1'
          }, {
            path: 'a',
            value: 'hashC 1.0'
          }
        ];
        oldHeadC = testBranchC.head;
        return testBranchC.merge({
          ref: dataAHashes[2]
        }, function() {
          return assertMerge(testBranchC, expectedData, [oldHeadC, dataAHashes[2]], done);
        });
      });
      return it('should merge branchA into an empty branch', function(done) {
        var emptyBranch;
        emptyBranch = repo.branch();
        return emptyBranch.merge({
          ref: testBranchA
        }, function(err, head) {
          assert.equal(head, testBranchA.head);
          return done();
        });
      });
    });
    describe('commit deletes', function() {
      return it('should delete data', function(done) {
        var data;
        data = {
          'b/c': null,
          'b/f/a': null,
          'b/f/g': null,
          'a': 1
        };
        return testBranchB.commit(data, function(err, head) {
          return testData(testBranchB, data, done);
        });
      });
    });
    describe('treeAtPath', function() {
      it('should read the root tree', function(done) {
        return testBranchA.treeAtPath('', function(err, tree) {
          assert.ok(tree.childData);
          return done();
        });
      });
      return it('should read a child tree', function(done) {
        return testBranchA.treeAtPath('b/f', function(err, tree) {
          assert.equal(tree.childData.g, dataA[1]['b/f/g']);
          return done();
        });
      });
    });
    return describe('paths', function(done) {
      return it('should return all tracked paths', function(done) {
        var expectedPaths, testBranch;
        testBranch = repo.branch(dataAHashes[0]);
        expectedPaths = keys(dataA[0]);
        return testBranch.allPaths(function(err, paths) {
          paths = pluck(paths, 'path');
          assert.equal(difference(paths, expectedPaths).length, 0);
          assert.equal(difference(expectedPaths, paths).length, 0);
          return done();
        });
      });
    });
  });

}).call(this);
