// Generated by CoffeeScript 1.3.3
(function() {
  var Branch, Repository, Tree, TreeStore, addKeyPrefix, async, clone, commit, contains, contentAddressable, findCommonCommit, findDelta, findDeltaDiff, findDiffWithPaths, findPaths, intersection, keyValueStore, keys, mergeDiffs, mergingCommit, objectDiff, objectDiffObject, pluck, read, readTreeAtPath, recurseUntilCommonCommit, splitCurrentAndChildTreeData, treeAncestors, treesAncestors, union, values, _, _ref,
    __slice = [].slice;

  async = require('async');

  _ = require('underscore');

  union = _.union, values = _.values, keys = _.keys, intersection = _.intersection, clone = _.clone, contains = _.contains, pluck = _.pluck;

  _ref = require('./utils'), objectDiff = _ref.objectDiff, objectDiffObject = _ref.objectDiffObject, addKeyPrefix = _ref.addKeyPrefix;

  Branch = require('./branch');

  TreeStore = require('./tree-store');

  contentAddressable = require('content-addressable').memory;

  keyValueStore = require('pluggable-store').memory;

  Tree = (function() {

    function Tree(_arg) {
      var ancestors, childData, childTrees, _ref1;
      _ref1 = _arg != null ? _arg : {}, ancestors = _ref1.ancestors, childTrees = _ref1.childTrees, childData = _ref1.childData;
      this.ancestors = ancestors ? ancestors : [];
      this.childTrees = childTrees ? childTrees : {};
      this.childData = childData ? childData : {};
    }

    return Tree;

  })();

  splitCurrentAndChildTreeData = function(data) {
    var childTreeData, currentTreeData, hash, key, path, _i, _len, _ref1;
    currentTreeData = {};
    childTreeData = {};
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      _ref1 = data[_i], path = _ref1.path, hash = _ref1.hash;
      key = path.pop();
      if (path.length === 0) {
        currentTreeData[key] = hash;
      } else {
        if (!childTreeData[key]) {
          childTreeData[key] = [];
        }
        childTreeData[key].push({
          path: path,
          hash: hash
        });
      }
    }
    return [currentTreeData, childTreeData];
  };

  commit = function(treeHash, data, treeStore) {
    var childTreeData, currentTree, currentTreeData, hash, key, newChildTree, previousTree, tree, _ref1;
    currentTree = treeHash ? (tree = treeStore.read(treeHash), new Tree({
      childData: clone(tree.childData),
      childTrees: clone(tree.childTrees),
      ancestors: [treeHash]
    })) : new Tree();
    _ref1 = splitCurrentAndChildTreeData(data), currentTreeData = _ref1[0], childTreeData = _ref1[1];
    for (key in currentTreeData) {
      hash = currentTreeData[key];
      if (hash) {
        currentTree.childData[key] = hash;
      } else {
        delete currentTree.childData[key];
      }
    }
    for (key in childTreeData) {
      data = childTreeData[key];
      previousTree = currentTree.childTrees[key];
      newChildTree = commit(previousTree, data, treeStore);
      if (newChildTree) {
        currentTree.childTrees[key] = newChildTree;
      } else {
        delete currentTree.childTrees[key];
      }
    }
    if ((_.size(currentTree.childTrees) > 0) || (_.size(currentTree.childData) > 0)) {
      return treeStore.write(currentTree);
    }
  };

  readTreeAtPath = function(treeHash, treeStore, path) {
    var key, tree;
    tree = treeStore.read(treeHash);
    if (path.length === 0) {
      return tree;
    } else {
      key = path.pop();
      return readTreeAtPath(tree.childTrees[key], treeStore, path);
    }
  };

  read = function(treeHash, treeStore, path) {
    var key, tree;
    if (!treeHash) {
      return void 0;
    } else {
      tree = treeStore.read(treeHash);
      key = path.pop();
      if (path.length === 0) {
        return tree.childData[key];
      } else {
        return read(tree.childTrees[key], treeStore, path);
      }
    }
  };

  findPaths = function(treeHash, treeStore) {
    var childPaths, childTree, each, key, paths, res, tree, _ref1;
    tree = treeStore.read(treeHash);
    paths = [];
    _ref1 = tree.childTrees;
    for (key in _ref1) {
      childTree = _ref1[key];
      childPaths = findPaths(childTree, treeStore);
      res = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = childPaths.length; _i < _len; _i++) {
          each = childPaths[_i];
          _results.push([key].concat(__slice.call(each)));
        }
        return _results;
      })();
      paths = paths.concat(res);
    }
    return paths.concat((function() {
      var _i, _len, _ref2, _results;
      _ref2 = keys(tree.childData);
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        each = _ref2[_i];
        _results.push([each]);
      }
      return _results;
    })());
  };

  treeAncestors = function(treeHash, treeStore) {
    return treeStore.read(treeHash).ancestors;
  };

  treesAncestors = function(treeStore) {
    return function(trees) {
      var each;
      return _.flatten((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = trees.length; _i < _len; _i++) {
          each = trees[_i];
          _results.push(treeAncestors(each, treeStore));
        }
        return _results;
      })());
    };
  };

  findCommonCommit = function(tree1, tree2, treeStore) {
    var each, trees1, trees2, _ref1;
    if ((!tree1) || (!tree2)) {
      return void 0;
    }
    _ref1 = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = [tree1, tree2];
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        each = _ref1[_i];
        _results.push({
          current: [each],
          visited: []
        });
      }
      return _results;
    })(), trees1 = _ref1[0], trees2 = _ref1[1];
    return recurseUntilCommonCommit(trees1, trees2, treeStore);
  };

  recurseUntilCommonCommit = function(trees1, trees2, treeStore) {
    var each, merge, trees1Parents, trees2Parents, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4;
    if ((trees1.current.length === 0) && (trees2.current.length === 0)) {
      return void 0;
    }
    _ref1 = [[trees1, trees2], [trees2, trees1]];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      _ref2 = _ref1[_i], trees1 = _ref2[0], trees2 = _ref2[1];
      _ref3 = trees1.current;
      for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
        each = _ref3[_j];
        if (_.contains(trees2.visited.concat(trees2.current), each)) {
          return each;
        }
      }
    }
    _ref4 = [trees1.current, trees2.current].map(treesAncestors(treeStore)), trees1Parents = _ref4[0], trees2Parents = _ref4[1];
    merge = function(oldTrees, newParents) {
      return {
        current: newParents,
        visited: oldTrees.visited.concat(oldTrees.current)
      };
    };
    return recurseUntilCommonCommit(merge(trees1, trees1Parents), merge(trees2, trees2Parents), treeStore);
  };

  findDiffWithPaths = function(tree1Hash, tree2Hash, treeStore) {
    var deletedData, diff, each, key, mapChildTree, tree1, tree2, updatedData, value, _ref1;
    if (tree1Hash === tree2Hash) {
      return {
        trees: [],
        data: []
      };
    }
    _ref1 = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = [tree1Hash, tree2Hash];
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        each = _ref1[_i];
        if (each) {
          _results.push(treeStore.read(each));
        } else {
          _results.push(new Tree());
        }
      }
      return _results;
    })(), tree1 = _ref1[0], tree2 = _ref1[1];
    diff = {
      data: [],
      trees: [
        {
          path: [],
          hash: tree2Hash ? tree2Hash : null
        }
      ]
    };
    updatedData = (function() {
      var _ref2, _results;
      _ref2 = tree2.childData;
      _results = [];
      for (key in _ref2) {
        value = _ref2[key];
        if (tree1.childData[key] !== value) {
          _results.push({
            path: [key],
            hash: value
          });
        }
      }
      return _results;
    })();
    deletedData = (function() {
      var _results;
      _results = [];
      for (key in tree1.childData) {
        if (tree2.childData[key] === void 0) {
          _results.push({
            path: [key],
            hash: null
          });
        }
      }
      return _results;
    })();
    diff.data = union(updatedData, deletedData);
    mapChildTree = function(diff, key) {
      var childDiff, prependPath;
      childDiff = findDiffWithPaths(tree1.childTrees[key], tree2.childTrees[key], treeStore);
      prependPath = function(pathHashs) {
        var hash, path, _i, _len, _ref2, _results;
        _results = [];
        for (_i = 0, _len = pathHashs.length; _i < _len; _i++) {
          _ref2 = pathHashs[_i], path = _ref2.path, hash = _ref2.hash;
          _results.push({
            path: [key].concat(__slice.call(path)),
            hash: hash
          });
        }
        return _results;
      };
      return {
        trees: union(diff.trees, prependPath(childDiff.trees)),
        data: union(diff.data, prependPath(childDiff.data))
      };
    };
    return union(keys(tree1.childTrees), keys(tree2.childTrees)).reduce(mapChildTree, diff);
  };

  mergeDiffs = function(oldDiff, newDiff) {
    return {
      trees: union(oldDiff.trees, newDiff.trees),
      data: union(oldDiff.data, newDiff.data)
    };
  };

  findDeltaDiff = function(tree1Hash, tree2Hash, treeStore) {
    var diff, each, key, mapChildTree, tree1, tree2, value, _ref1;
    if (tree1Hash === tree2Hash) {
      return {
        trees: [],
        data: []
      };
    }
    _ref1 = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = [tree1Hash, tree2Hash];
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        each = _ref1[_i];
        if (each) {
          _results.push(treeStore.read(each));
        } else {
          _results.push(new Tree());
        }
      }
      return _results;
    })(), tree1 = _ref1[0], tree2 = _ref1[1];
    diff = {
      data: [],
      trees: tree2Hash ? [tree2Hash] : []
    };
    diff.data = (function() {
      var _ref2, _results;
      _ref2 = tree2.childData;
      _results = [];
      for (key in _ref2) {
        value = _ref2[key];
        if (tree1.childData[key] !== value) {
          _results.push(value);
        }
      }
      return _results;
    })();
    mapChildTree = function(diff, key) {
      var childDiff;
      childDiff = findDeltaDiff(tree1.childTrees[key], tree2.childTrees[key], treeStore);
      return mergeDiffs(diff, childDiff);
    };
    return union(keys(tree1.childTrees), keys(tree2.childTrees)).reduce(mapChildTree, diff);
  };

  findDelta = function(commonTreeHash, toTreeHash, knownTrees, treeStore) {
    var ancestor, ancestorDiffs, diff, reduceFun, toTree;
    if ((toTreeHash === commonTreeHash) || (contains(knownTrees, toTreeHash))) {
      return {
        trees: [],
        data: []
      };
    }
    toTree = treeStore.read(toTreeHash);
    ancestorDiffs = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = toTree.ancestors;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        ancestor = _ref1[_i];
        _results.push(findDeltaDiff(ancestor, toTreeHash, treeStore));
      }
      return _results;
    })();
    if (toTree.ancestors.length === 1) {
      return mergeDiffs(ancestorDiffs[0], findDelta(commonTreeHash, toTree.ancestors[0], knownTrees, treeStore));
    } else if (toTree.ancestors.length === 0) {
      return findDeltaDiff(null, toTreeHash, treeStore);
    } else {
      diff = {
        trees: union.apply(null, pluck(ancestorDiffs, 'trees')),
        data: intersection.apply(null, pluck(ancestorDiffs, 'data'))
      };
      reduceFun = function(diff, ancestor) {
        var newCommonTreeHash;
        newCommonTreeHash = findCommonCommit(ancestor, commonTreeHash, treeStore);
        return mergeDiffs(diff, findDelta(newCommonTreeHash, ancestor, knownTrees, treeStore));
      };
      return toTree.ancestors.reduce(reduceFun, diff);
    }
  };

  mergingCommit = function(commonTreeHash, tree1Hash, tree2Hash, strategy, treeStore) {
    var ancestors, commonTree, conflict, each, mergeChildTrees, mergeData, newTree, tree1, tree2, _ref1;
    conflict = (commonTreeHash !== tree1Hash) && (commonTreeHash !== tree2Hash);
    if (!conflict) {
      if (tree1Hash === commonTreeHash) {
        return tree2Hash;
      } else {
        return tree1Hash;
      }
    } else {
      _ref1 = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = [commonTreeHash, tree1Hash, tree2Hash];
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          each = _ref1[_i];
          if (each) {
            _results.push(treeStore.read(each));
          } else {
            _results.push(new Tree());
          }
        }
        return _results;
      })(), commonTree = _ref1[0], tree1 = _ref1[1], tree2 = _ref1[2];
      ancestors = (function() {
        var _i, _len, _ref2, _results;
        _ref2 = [tree1Hash, tree2Hash];
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          each = _ref2[_i];
          if (each) {
            _results.push(each);
          }
        }
        return _results;
      })();
      newTree = new Tree({
        ancestors: ancestors
      });
      mergeData = function() {
        var commonData, data1, data2, key, _i, _len, _ref2, _results;
        _ref2 = union(keys(tree2.childData), keys(tree1.childData));
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          key = _ref2[_i];
          commonData = commonTree.childData[key];
          data1 = tree1.childData[key];
          data2 = tree2.childData[key];
          conflict = (commonData !== data1) && (commonData !== data2);
          if (conflict) {
            _results.push(newTree.childData[key] = strategy(key, data1, data2));
          } else {
            _results.push(newTree.childData[key] = data1 === commonData ? data2 : data1);
          }
        }
        return _results;
      };
      mergeChildTrees = function() {
        var key, _i, _len, _ref2, _results;
        _ref2 = keys(tree2.childTrees);
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          key = _ref2[_i];
          _results.push(newTree.childTrees[key] = mergingCommit(commonTree.childTrees[key], tree1.childTrees[key], tree2.childTrees[key], strategy, treeStore));
        }
        return _results;
      };
      mergeData();
      mergeChildTrees();
      return treeStore.write(newTree);
    }
  };

  Repository = (function() {

    function Repository(_arg) {
      this.treeStore = (_arg != null ? _arg : {}).treeStore;
      if (!this.treeStore) {
        this.treeStore = contentAddressable();
      }
      this._treeStore = new TreeStore(this.treeStore);
    }

    Repository.prototype.branch = function(treeHash) {
      return new Branch(this, treeHash);
    };

    Repository.prototype.commit = function(oldTree, data) {
      var hash, parsedData, path;
      parsedData = (function() {
        var _results;
        _results = [];
        for (path in data) {
          hash = data[path];
          _results.push({
            path: path.split('/').reverse(),
            hash: hash
          });
        }
        return _results;
      })();
      return commit(oldTree, parsedData, this._treeStore);
    };

    Repository.prototype.treeAtPath = function(tree, path) {
      path = path === '' ? [] : path.split('/').reverse();
      return readTreeAtPath(tree, this._treeStore, path);
    };

    Repository.prototype.dataAtPath = function(tree, path) {
      path = path.split('/').reverse();
      return read(tree, this._treeStore, path);
    };

    Repository.prototype.paths = function(treeHash) {
      var each, _i, _len, _ref1, _results;
      _ref1 = findPaths(treeHash, this._treeStore);
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        each = _ref1[_i];
        _results.push(each.join('/'));
      }
      return _results;
    };

    Repository.prototype.commonCommit = function(tree1, tree2) {
      return findCommonCommit(tree1, tree2, this._treeStore);
    };

    Repository.prototype.diff = function(tree1, tree2) {
      var diff, translatePaths;
      diff = findDiffWithPaths(tree1, tree2, this._treeStore);
      translatePaths = function(array) {
        var hash, path, _i, _len, _ref1, _results;
        _results = [];
        for (_i = 0, _len = array.length; _i < _len; _i++) {
          _ref1 = array[_i], path = _ref1.path, hash = _ref1.hash;
          _results.push({
            path: path.join('/'),
            hash: hash
          });
        }
        return _results;
      };
      return {
        trees: translatePaths(diff.trees),
        data: translatePaths(diff.data)
      };
    };

    Repository.prototype.deltaHashs = function(_arg) {
      var commonTree, diff, eachTo, from, to, _i, _len;
      from = _arg.from, to = _arg.to;
      to = to.constructor === Array ? to : [to];
      diff = {
        trees: [],
        data: []
      };
      for (_i = 0, _len = to.length; _i < _len; _i++) {
        eachTo = to[_i];
        commonTree = this.commonCommit(from, eachTo);
        diff = mergeDiffs(diff, findDelta(commonTree, eachTo, diff.trees, this._treeStore));
      }
      return diff;
    };

    Repository.prototype.deltaData = function(delta) {
      var each;
      return {
        trees: (function() {
          var _i, _len, _ref1, _results;
          _ref1 = delta.trees;
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            each = _ref1[_i];
            _results.push(this.treeStore.read(each));
          }
          return _results;
        }).call(this),
        data: delta.data
      };
    };

    Repository.prototype.merge = function(tree1, tree2, strategy) {
      var commonTree, obj;
      obj = this;
      strategy = strategy ? strategy : function(path, value1Hash, value2Hash) {
        return value1Hash;
      };
      commonTree = this.commonCommit(tree1, tree2);
      if (tree1 === commonTree) {
        return tree2;
      } else if (tree2 === commonTree) {
        return tree1;
      } else {
        return mergingCommit(commonTree, tree1, tree2, strategy, this._treeStore);
      }
    };

    return Repository;

  })();

  module.exports = Repository;

}).call(this);
