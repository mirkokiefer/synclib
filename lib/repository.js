// Generated by CoffeeScript 1.3.3
(function() {
  var Branch, Commit, Queue, Repository, Store, Tree, addKeyPrefix, allPaths, async, clone, commit, commitAncestors, contains, contentAddressable, findCommonCommit, findCommonCommitWithPaths, findDelta, findDeltaDiff, findDiffWithPaths, findWalkPath, groupCurrentAndChildTreeData, intersection, keyValueStore, keys, mergeDiffs, mergingCommit, objectDiff, objectDiffObject, pluck, read, readTreeAtPath, union, values, _, _ref,
    __slice = [].slice;

  async = require('async');

  _ = require('underscore');

  union = _.union, values = _.values, keys = _.keys, intersection = _.intersection, clone = _.clone, contains = _.contains, pluck = _.pluck;

  _ref = require('./utils'), objectDiff = _ref.objectDiff, objectDiffObject = _ref.objectDiffObject, addKeyPrefix = _ref.addKeyPrefix, Queue = _ref.Queue;

  Branch = require('./branch');

  Store = require('./store');

  contentAddressable = require('content-addressable').memory;

  keyValueStore = require('pluggable-store').memory;

  Tree = (function() {

    function Tree(_arg) {
      var childData, childTrees, _ref1;
      _ref1 = _arg != null ? _arg : {}, childTrees = _ref1.childTrees, childData = _ref1.childData;
      this.childTrees = childTrees ? childTrees : {};
      this.childData = childData ? childData : {};
    }

    return Tree;

  })();

  Tree.serialize = function(obj) {
    var childData, childTrees, sort;
    sort = function(arr) {
      return arr.sort(function(a, b) {
        return a[0] > b[0];
      });
    };
    childTrees = sort(_.pairs(obj.childTrees));
    childData = sort(_.pairs(obj.childData));
    return JSON.stringify([childTrees, childData]);
  };

  Tree.deserialize = function(string) {
    var childData, childTrees, _ref1;
    _ref1 = JSON.parse(string), childTrees = _ref1[0], childData = _ref1[1];
    return new Tree({
      childTrees: _.object(childTrees),
      childData: _.object(childData)
    });
  };

  Commit = (function() {

    function Commit(_arg) {
      var ancestors, info, _ref1;
      _ref1 = _arg != null ? _arg : {}, ancestors = _ref1.ancestors, this.tree = _ref1.tree, info = _ref1.info;
      this.ancestors = ancestors ? ancestors : [];
      this.info = info ? info : [];
    }

    return Commit;

  })();

  Commit.serialize = function(obj) {
    return JSON.stringify([obj.ancestors.sort(), obj.tree, obj.info]);
  };

  Commit.deserialize = function(string) {
    var ancestors, info, tree, _ref1;
    _ref1 = JSON.parse(string), ancestors = _ref1[0], tree = _ref1[1], info = _ref1[2];
    return new Commit({
      ancestors: ancestors,
      tree: tree,
      info: info
    });
  };

  groupCurrentAndChildTreeData = function(data) {
    var childTreeData, currentTreeData, key, path, value, _i, _len, _ref1;
    currentTreeData = {};
    childTreeData = {};
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      _ref1 = data[_i], path = _ref1.path, value = _ref1.value;
      key = path.pop();
      if (path.length === 0) {
        currentTreeData[key] = value;
      } else {
        if (!childTreeData[key]) {
          childTreeData[key] = [];
        }
        childTreeData[key].push({
          path: path,
          value: value
        });
      }
    }
    return [currentTreeData, childTreeData];
  };

  commit = function(treeHash, data, treeStore) {
    var childTreeData, currentTree, currentTreeData, key, newChildTree, previousTree, value, _ref1;
    if (data.length === 0) {
      return treeHash;
    }
    currentTree = treeHash ? treeStore.read(treeHash) : new Tree();
    _ref1 = groupCurrentAndChildTreeData(data), currentTreeData = _ref1[0], childTreeData = _ref1[1];
    for (key in currentTreeData) {
      value = currentTreeData[key];
      if (currentTree.childData[key] !== value) {
        if (value) {
          currentTree.childData[key] = value;
        } else {
          delete currentTree.childData[key];
        }
      }
    }
    for (key in childTreeData) {
      data = childTreeData[key];
      previousTree = currentTree.childTrees[key];
      newChildTree = commit(previousTree, data, treeStore);
      if (newChildTree !== previousTree) {
        if (newChildTree) {
          currentTree.childTrees[key] = newChildTree;
        } else {
          delete currentTree.childTrees[key];
        }
      }
    }
    if ((_.size(currentTree.childTrees) > 0) || (_.size(currentTree.childData) > 0)) {
      return treeStore.write(currentTree);
    }
  };

  readTreeAtPath = function(treeHash, treeStore, path) {
    var key, tree;
    tree = treeStore.read(treeHash);
    if (path.length === 0) {
      return tree;
    } else {
      key = path.pop();
      return readTreeAtPath(tree.childTrees[key], treeStore, path);
    }
  };

  read = function(treeHash, treeStore, path) {
    var key, tree;
    if (!treeHash) {
      return void 0;
    } else {
      tree = treeStore.read(treeHash);
      key = path.pop();
      if (path.length === 0) {
        return tree.childData[key];
      } else {
        return read(tree.childTrees[key], treeStore, path);
      }
    }
  };

  allPaths = function(treeHash, treeStore) {
    var childPaths, childTree, key, path, paths, res, tree, value, _ref1;
    tree = treeStore.read(treeHash);
    paths = [];
    _ref1 = tree.childTrees;
    for (key in _ref1) {
      childTree = _ref1[key];
      childPaths = allPaths(childTree, treeStore);
      res = (function() {
        var _i, _len, _ref2, _results;
        _results = [];
        for (_i = 0, _len = childPaths.length; _i < _len; _i++) {
          _ref2 = childPaths[_i], path = _ref2.path, value = _ref2.value;
          _results.push({
            path: [key].concat(__slice.call(path)),
            value: value
          });
        }
        return _results;
      })();
      paths = paths.concat(res);
    }
    return paths.concat((function() {
      var _ref2, _results;
      _ref2 = tree.childData;
      _results = [];
      for (key in _ref2) {
        value = _ref2[key];
        _results.push({
          path: [key],
          value: value
        });
      }
      return _results;
    })());
  };

  commitAncestors = function(commitHash, commitStore) {
    var commitObj;
    commitObj = commitStore.read(commitHash);
    if (commitObj) {
      return commitObj.ancestors;
    } else {
      return [];
    }
  };

  findWalkPath = function(tree, visited) {
    var arr;
    arr = [tree];
    while ((tree = visited[tree])) {
      arr.push(tree);
    }
    return arr;
  };

  findCommonCommitWithPaths = function(commit1Start, commit2Start, commitStore) {
    var ancestors, commit1, commit2, commitHash, each, visited, walker, walker1, walker2, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3, _ref4, _ref5;
    if ((!commit1Start) || (!commit2Start)) {
      return void 0;
    }
    _ref1 = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = [commit1Start, commit2Start];
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        each = _ref1[_i];
        walker = {
          queue: new Queue,
          visited: {}
        };
        walker.queue.push(each);
        walker.visited[each] = null;
        _results.push(walker);
      }
      return _results;
    })(), walker1 = _ref1[0], walker2 = _ref1[1];
    while ((commit1 = walker1.queue.pop()) || (commit2 = walker2.queue.pop())) {
      _ref2 = [[commit1, walker2.visited], [commit2, walker1.visited]];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        _ref3 = _ref2[_i], commitHash = _ref3[0], visited = _ref3[1];
        if (visited[commitHash] !== void 0) {
          return {
            commit: commitHash,
            commit1Path: findWalkPath(commitHash, walker1.visited),
            commit2Path: findWalkPath(commitHash, walker2.visited)
          };
        }
      }
      _ref4 = [[commit1, walker1], [commit2, walker2]];
      for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
        _ref5 = _ref4[_j], commitHash = _ref5[0], walker = _ref5[1];
        ancestors = commitAncestors(commitHash, commitStore);
        for (_k = 0, _len2 = ancestors.length; _k < _len2; _k++) {
          each = ancestors[_k];
          walker.queue.push(each);
          if (!walker.visited[each]) {
            walker.visited[each] = commitHash;
          }
        }
      }
    }
    return void 0;
  };

  findCommonCommit = function(commit1, commit2, commitStore) {
    var res;
    res = findCommonCommitWithPaths(commit1, commit2, commitStore);
    if (res) {
      return res.commit;
    }
  };

  findDiffWithPaths = function(tree1Hash, tree2Hash, treeStore) {
    var deletedData, diff, each, key, mapChildTree, tree1, tree2, updatedData, value, _ref1;
    if (tree1Hash === tree2Hash) {
      return {
        trees: [],
        values: []
      };
    }
    _ref1 = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = [tree1Hash, tree2Hash];
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        each = _ref1[_i];
        if (each) {
          _results.push(treeStore.read(each));
        } else {
          _results.push(new Tree());
        }
      }
      return _results;
    })(), tree1 = _ref1[0], tree2 = _ref1[1];
    diff = {
      values: [],
      trees: [
        {
          path: [],
          value: tree2Hash ? tree2Hash : null
        }
      ]
    };
    updatedData = (function() {
      var _ref2, _results;
      _ref2 = tree2.childData;
      _results = [];
      for (key in _ref2) {
        value = _ref2[key];
        if (tree1.childData[key] !== value) {
          _results.push({
            path: [key],
            value: value
          });
        }
      }
      return _results;
    })();
    deletedData = (function() {
      var _results;
      _results = [];
      for (key in tree1.childData) {
        if (tree2.childData[key] === void 0) {
          _results.push({
            path: [key],
            value: null
          });
        }
      }
      return _results;
    })();
    diff.values = union(updatedData, deletedData);
    mapChildTree = function(diff, key) {
      var childDiff, prependPath;
      childDiff = findDiffWithPaths(tree1.childTrees[key], tree2.childTrees[key], treeStore);
      prependPath = function(pathHashs) {
        var path, _i, _len, _ref2, _results;
        _results = [];
        for (_i = 0, _len = pathHashs.length; _i < _len; _i++) {
          _ref2 = pathHashs[_i], path = _ref2.path, value = _ref2.value;
          _results.push({
            path: [key].concat(__slice.call(path)),
            value: value
          });
        }
        return _results;
      };
      return {
        trees: union(diff.trees, prependPath(childDiff.trees)),
        values: union(diff.values, prependPath(childDiff.values))
      };
    };
    return union(keys(tree1.childTrees), keys(tree2.childTrees)).reduce(mapChildTree, diff);
  };

  findDeltaDiff = function(tree1Hash, tree2Hash, treeStore) {
    var diff, each, key, mapChildTree, tree1, tree2, value, _ref1;
    if (tree1Hash === tree2Hash) {
      return {
        trees: [],
        values: []
      };
    }
    _ref1 = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = [tree1Hash, tree2Hash];
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        each = _ref1[_i];
        if (each) {
          _results.push(treeStore.read(each));
        } else {
          _results.push(new Tree());
        }
      }
      return _results;
    })(), tree1 = _ref1[0], tree2 = _ref1[1];
    diff = {
      values: [],
      trees: tree2Hash ? [tree2Hash] : []
    };
    diff.values = (function() {
      var _ref2, _results;
      _ref2 = tree2.childData;
      _results = [];
      for (key in _ref2) {
        value = _ref2[key];
        if (tree1.childData[key] !== value) {
          _results.push(value);
        }
      }
      return _results;
    })();
    mapChildTree = function(diff, key) {
      var childDiff;
      childDiff = findDeltaDiff(tree1.childTrees[key], tree2.childTrees[key], treeStore);
      return {
        trees: union(diff.trees, childDiff.trees),
        values: union(diff.values, childDiff.values)
      };
    };
    return union(keys(tree1.childTrees), keys(tree2.childTrees)).reduce(mapChildTree, diff);
  };

  mergeDiffs = function(oldDiff, newDiff) {
    if (!newDiff.commits) {
      newDiff.commits = [];
    }
    return {
      commits: union(oldDiff.commits, newDiff.commits),
      trees: union(oldDiff.trees, newDiff.trees),
      values: union(oldDiff.values, newDiff.values)
    };
  };

  findDelta = function(commonCommitHashs, toCommitHash, treeStore, commitStore) {
    var ancestor, ancestorDiffs, diff, reduceFun, toCommit;
    if (contains(commonCommitHashs, toCommitHash)) {
      return {
        commits: [],
        trees: [],
        values: []
      };
    }
    diff = {
      commits: [toCommitHash],
      trees: [],
      values: []
    };
    toCommit = commitStore.read(toCommitHash);
    ancestorDiffs = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = toCommit.ancestors;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        ancestor = _ref1[_i];
        _results.push(findDeltaDiff(commitStore.read(ancestor).tree, toCommit.tree, treeStore));
      }
      return _results;
    })();
    if (toCommit.ancestors.length === 1) {
      diff = mergeDiffs(diff, ancestorDiffs[0]);
      return mergeDiffs(diff, findDelta(commonCommitHashs, toCommit.ancestors[0], treeStore, commitStore));
    } else if (toCommit.ancestors.length === 0) {
      return mergeDiffs(diff, findDeltaDiff(null, toCommit.tree, treeStore));
    } else {
      diff = mergeDiffs(diff, {
        trees: intersection.apply(null, pluck(ancestorDiffs, 'trees')),
        values: intersection.apply(null, pluck(ancestorDiffs, 'values'))
      });
      reduceFun = function(diff, ancestor) {
        var each, newCommonTreeHashs;
        newCommonTreeHashs = union((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = commonCommitHashs.length; _i < _len; _i++) {
            each = commonCommitHashs[_i];
            _results.push(findCommonCommit(ancestor, each, treeStore));
          }
          return _results;
        })());
        return mergeDiffs(diff, findDelta(newCommonTreeHashs, ancestor, treeStore, commitStore));
      };
      return toCommit.ancestors.reduce(reduceFun, diff);
    }
  };

  mergingCommit = function(commonTreeHash, tree1Hash, tree2Hash, strategy, treeStore) {
    var commonTree, conflict, each, mergeChildTrees, mergeData, newTree, tree1, tree2, _ref1;
    conflict = (commonTreeHash !== tree1Hash) && (commonTreeHash !== tree2Hash);
    if (!conflict) {
      if (tree1Hash === commonTreeHash) {
        return tree2Hash;
      } else {
        return tree1Hash;
      }
    } else {
      _ref1 = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = [commonTreeHash, tree1Hash, tree2Hash];
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          each = _ref1[_i];
          if (each) {
            _results.push(treeStore.read(each));
          } else {
            _results.push(new Tree());
          }
        }
        return _results;
      })(), commonTree = _ref1[0], tree1 = _ref1[1], tree2 = _ref1[2];
      newTree = new Tree;
      mergeData = function() {
        var commonData, data1, data2, key, _i, _len, _ref2, _results;
        _ref2 = union(keys(tree2.childData), keys(tree1.childData));
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          key = _ref2[_i];
          commonData = commonTree.childData[key];
          data1 = tree1.childData[key];
          data2 = tree2.childData[key];
          conflict = (commonData !== data1) && (commonData !== data2);
          if (conflict) {
            _results.push(newTree.childData[key] = strategy(key, data1, data2));
          } else {
            _results.push(newTree.childData[key] = data1 === commonData ? data2 : data1);
          }
        }
        return _results;
      };
      mergeChildTrees = function() {
        var key, _i, _len, _ref2, _results;
        _ref2 = union(keys(tree2.childTrees), keys(tree1.childTrees));
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          key = _ref2[_i];
          _results.push(newTree.childTrees[key] = mergingCommit(commonTree.childTrees[key], tree1.childTrees[key], tree2.childTrees[key], strategy, treeStore));
        }
        return _results;
      };
      mergeData();
      mergeChildTrees();
      return treeStore.write(newTree);
    }
  };

  Repository = (function() {

    function Repository(_arg) {
      var _ref1;
      _ref1 = _arg != null ? _arg : {}, this.treeStore = _ref1.treeStore, this.commitStore = _ref1.commitStore;
      if (!this.treeStore) {
        this.treeStore = contentAddressable();
      }
      if (!this.commitStore) {
        this.commitStore = contentAddressable();
      }
      this._treeStore = new Store(this.treeStore, Tree);
      this._commitStore = new Store(this.commitStore, Commit);
    }

    Repository.prototype.branch = function(treeHash) {
      return new Branch(this, treeHash);
    };

    Repository.prototype.commit = function(oldCommitHash, data) {
      var ancestors, newCommit, newTree, oldTree, parsedData, path, value;
      oldTree = oldCommitHash ? this._commitStore.read(oldCommitHash).tree : void 0;
      parsedData = (function() {
        var _results;
        _results = [];
        for (path in data) {
          value = data[path];
          _results.push({
            path: path.split('/').reverse(),
            value: value
          });
        }
        return _results;
      })();
      newTree = commit(oldTree, parsedData, this._treeStore);
      if (newTree === oldTree) {
        return oldCommitHash;
      } else {
        ancestors = oldCommitHash ? [oldCommitHash] : [];
        newCommit = new Commit({
          ancestors: ancestors,
          tree: newTree
        });
        return this._commitStore.write(newCommit);
      }
    };

    Repository.prototype.treeAtPath = function(commitHash, path) {
      var tree;
      path = path === '' ? [] : path.split('/').reverse();
      tree = this._commitStore.read(commitHash).tree;
      return readTreeAtPath(tree, this._treeStore, path);
    };

    Repository.prototype.dataAtPath = function(commitHash, path) {
      var tree;
      path = path.split('/').reverse();
      tree = this._commitStore.read(commitHash).tree;
      return read(tree, this._treeStore, path);
    };

    Repository.prototype.allPaths = function(commitHash) {
      var path, tree, value, _i, _len, _ref1, _ref2, _results;
      tree = this._commitStore.read(commitHash).tree;
      _ref1 = allPaths(tree, this._treeStore);
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        _ref2 = _ref1[_i], path = _ref2.path, value = _ref2.value;
        _results.push({
          path: path.join('/'),
          value: value
        });
      }
      return _results;
    };

    Repository.prototype.commonCommit = function(commit1, commit2) {
      return findCommonCommit(commit1, commit2, this._commitStore);
    };

    Repository.prototype.commonCommitWithPaths = function(commit1, commit2) {
      return findCommonCommitWithPaths(commit1, commit2, this._commitStore);
    };

    Repository.prototype.diff = function(commit1, commit2) {
      var diff, each, translatePaths, tree1, tree2, _ref1;
      _ref1 = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = [commit1, commit2];
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          each = _ref1[_i];
          if (each) {
            _results.push(this._commitStore.read(each).tree);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }).call(this), tree1 = _ref1[0], tree2 = _ref1[1];
      diff = findDiffWithPaths(tree1, tree2, this._treeStore);
      translatePaths = function(array) {
        var path, value, _i, _len, _ref2, _results;
        _results = [];
        for (_i = 0, _len = array.length; _i < _len; _i++) {
          _ref2 = array[_i], path = _ref2.path, value = _ref2.value;
          _results.push({
            path: path.join('/'),
            value: value
          });
        }
        return _results;
      };
      return {
        trees: translatePaths(diff.trees),
        values: translatePaths(diff.values)
      };
    };

    Repository.prototype.deltaHashs = function(_arg) {
      var commonCommits, diff, from, fromEach, to, toEach, _i, _len;
      from = _arg.from, to = _arg.to;
      diff = {
        commits: [],
        trees: [],
        values: []
      };
      for (_i = 0, _len = to.length; _i < _len; _i++) {
        toEach = to[_i];
        commonCommits = (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = from.length; _j < _len1; _j++) {
            fromEach = from[_j];
            _results.push(this.commonCommit(fromEach, toEach));
          }
          return _results;
        }).call(this);
        diff = mergeDiffs(diff, findDelta(commonCommits, toEach, this._treeStore, this._commitStore));
      }
      return diff;
    };

    Repository.prototype.deltaData = function(delta) {
      var each;
      return {
        commits: (function() {
          var _i, _len, _ref1, _results;
          _ref1 = delta.commits;
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            each = _ref1[_i];
            _results.push(this.commitStore.read(each));
          }
          return _results;
        }).call(this),
        trees: (function() {
          var _i, _len, _ref1, _results;
          _ref1 = delta.trees;
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            each = _ref1[_i];
            _results.push(this.treeStore.read(each));
          }
          return _results;
        }).call(this),
        values: delta.values
      };
    };

    Repository.prototype.merge = function(commit1, commit2, strategy) {
      var commonCommit, commonTree, each, newTree, obj, tree1, tree2, _ref1;
      obj = this;
      strategy = strategy ? strategy : function(path, value1Hash, value2Hash) {
        return value1Hash;
      };
      commonCommit = this.commonCommit(commit1, commit2);
      if (commit1 === commonCommit) {
        return commit2;
      } else if (commit2 === commonCommit) {
        return commit1;
      } else {
        _ref1 = (function() {
          var _i, _len, _ref1, _results;
          _ref1 = [commonCommit, commit1, commit2];
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            each = _ref1[_i];
            if (each) {
              _results.push(this._commitStore.read(each).tree);
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        }).call(this), commonTree = _ref1[0], tree1 = _ref1[1], tree2 = _ref1[2];
        newTree = mergingCommit(commonTree, tree1, tree2, strategy, this._treeStore);
        return this._commitStore.write(new Commit({
          ancestors: [commit1, commit2],
          tree: newTree
        }));
      }
    };

    return Repository;

  })();

  module.exports = Repository;

}).call(this);
