// Generated by CoffeeScript 1.3.3
(function() {
  var Branch, Commit, Queue, Repository, Store, Tree, addKeyPrefix, allPaths, async, clone, commit, commitAncestors, contains, contentAddressable, findCommonCommit, findCommonCommitWithPaths, findDelta, findDeltaDiff, findDiffWithPaths, findWalkPath, groupCurrentAndChildTreeData, intersection, keyValueStore, keys, mergeDiffs, mergingCommit, objectDiff, objectDiffObject, pairs, pluck, read, readTreeAtPath, union, values, _, _ref,
    __slice = [].slice;

  async = require('async');

  _ = require('underscore');

  union = _.union, values = _.values, keys = _.keys, intersection = _.intersection, clone = _.clone, contains = _.contains, pluck = _.pluck, pairs = _.pairs;

  _ref = require('./utils'), objectDiff = _ref.objectDiff, objectDiffObject = _ref.objectDiffObject, addKeyPrefix = _ref.addKeyPrefix, Queue = _ref.Queue;

  Branch = require('./branch');

  Store = require('./store');

  contentAddressable = require('content-addressable').memory;

  keyValueStore = require('pluggable-store').memory;

  Tree = (function() {

    function Tree(_arg) {
      var childData, childTrees, _ref1;
      _ref1 = _arg != null ? _arg : {}, childTrees = _ref1.childTrees, childData = _ref1.childData;
      this.childTrees = childTrees ? childTrees : {};
      this.childData = childData ? childData : {};
    }

    return Tree;

  })();

  Tree.serialize = function(obj) {
    var childData, childTrees, sort;
    sort = function(arr) {
      return arr.sort(function(a, b) {
        return a[0] > b[0];
      });
    };
    childTrees = sort(_.pairs(obj.childTrees));
    childData = sort(_.pairs(obj.childData));
    return JSON.stringify([childTrees, childData]);
  };

  Tree.deserialize = function(string) {
    var childData, childTrees, _ref1;
    _ref1 = JSON.parse(string), childTrees = _ref1[0], childData = _ref1[1];
    return new Tree({
      childTrees: _.object(childTrees),
      childData: _.object(childData)
    });
  };

  Commit = (function() {

    function Commit(_arg) {
      var ancestors, info, _ref1;
      _ref1 = _arg != null ? _arg : {}, ancestors = _ref1.ancestors, this.tree = _ref1.tree, info = _ref1.info;
      this.ancestors = ancestors ? ancestors : [];
      this.info = info ? info : [];
    }

    return Commit;

  })();

  Commit.serialize = function(obj) {
    return JSON.stringify([obj.ancestors.sort(), obj.tree, obj.info]);
  };

  Commit.deserialize = function(string) {
    var ancestors, info, tree, _ref1;
    _ref1 = JSON.parse(string), ancestors = _ref1[0], tree = _ref1[1], info = _ref1[2];
    return new Commit({
      ancestors: ancestors,
      tree: tree,
      info: info
    });
  };

  groupCurrentAndChildTreeData = function(data) {
    var childTreeData, currentTreeData, key, path, value, _i, _len, _ref1;
    currentTreeData = {};
    childTreeData = {};
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      _ref1 = data[_i], path = _ref1.path, value = _ref1.value;
      key = path.pop();
      if (path.length === 0) {
        currentTreeData[key] = value;
      } else {
        if (!childTreeData[key]) {
          childTreeData[key] = [];
        }
        childTreeData[key].push({
          path: path,
          value: value
        });
      }
    }
    return [currentTreeData, childTreeData];
  };

  commit = function(treeHash, data, treeStore, cb) {
    if (data.length === 0) {
      return cb(null, treeHash);
    }
    return treeStore.read(treeHash, function(err, currentTree) {
      var childTreeData, currentTreeData, forEachChildTree, key, value, _ref1;
      if (!currentTree) {
        currentTree = new Tree();
      }
      _ref1 = groupCurrentAndChildTreeData(data), currentTreeData = _ref1[0], childTreeData = _ref1[1];
      for (key in currentTreeData) {
        value = currentTreeData[key];
        if (currentTree.childData[key] !== value) {
          if (value) {
            currentTree.childData[key] = value;
          } else {
            delete currentTree.childData[key];
          }
        }
      }
      forEachChildTree = function(_arg, cb) {
        var data, key, previousTree;
        key = _arg[0], data = _arg[1];
        previousTree = currentTree.childTrees[key];
        return commit(previousTree, data, treeStore, function(err, newChildTree) {
          if (newChildTree !== previousTree) {
            if (newChildTree) {
              currentTree.childTrees[key] = newChildTree;
            } else {
              delete currentTree.childTrees[key];
            }
          }
          return cb();
        });
      };
      return async.forEach(pairs(childTreeData), forEachChildTree, function() {
        if ((_.size(currentTree.childTrees) > 0) || (_.size(currentTree.childData) > 0)) {
          return treeStore.write(currentTree, cb);
        }
      });
    });
  };

  readTreeAtPath = function(treeHash, treeStore, path) {
    var key, tree;
    tree = treeStore.read(treeHash);
    if (path.length === 0) {
      return tree;
    } else {
      key = path.pop();
      return readTreeAtPath(tree.childTrees[key], treeStore, path);
    }
  };

  read = function(treeHash, treeStore, path, cb) {
    if (!treeHash) {
      return void 0;
    } else {
      return treeStore.read(treeHash, function(err, tree) {
        var key;
        key = path.pop();
        if (path.length === 0) {
          return cb(null, tree.childData[key]);
        } else {
          return read(tree.childTrees[key], treeStore, path, cb);
        }
      });
    }
  };

  allPaths = function(treeHash, treeStore) {
    var childPaths, childTree, key, path, paths, res, tree, value, _ref1;
    tree = treeStore.read(treeHash);
    paths = [];
    _ref1 = tree.childTrees;
    for (key in _ref1) {
      childTree = _ref1[key];
      childPaths = allPaths(childTree, treeStore);
      res = (function() {
        var _i, _len, _ref2, _results;
        _results = [];
        for (_i = 0, _len = childPaths.length; _i < _len; _i++) {
          _ref2 = childPaths[_i], path = _ref2.path, value = _ref2.value;
          _results.push({
            path: [key].concat(__slice.call(path)),
            value: value
          });
        }
        return _results;
      })();
      paths = paths.concat(res);
    }
    return paths.concat((function() {
      var _ref2, _results;
      _ref2 = tree.childData;
      _results = [];
      for (key in _ref2) {
        value = _ref2[key];
        _results.push({
          path: [key],
          value: value
        });
      }
      return _results;
    })());
  };

  commitAncestors = function(commitHash, commitStore, cb) {
    return commitStore.read(commitHash, function(err, commitObj) {
      if (commitObj) {
        return cb(null, commitObj.ancestors);
      } else {
        return cb(null, []);
      }
    });
  };

  findWalkPath = function(tree, visited) {
    var arr;
    arr = [tree];
    while ((tree = visited[tree])) {
      arr.push(tree);
    }
    return arr;
  };

  findCommonCommitWithPaths = function(commit1Start, commit2Start, commitStore, cb) {
    var condition, each, result, walkOneLevel, walker, walker1, walker2, _ref1;
    if ((!commit1Start) || (!commit2Start)) {
      return void 0;
    }
    _ref1 = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = [commit1Start, commit2Start];
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        each = _ref1[_i];
        walker = {
          queue: new Queue,
          visited: {}
        };
        walker.queue.push(each);
        walker.visited[each] = null;
        _results.push(walker);
      }
      return _results;
    })(), walker1 = _ref1[0], walker2 = _ref1[1];
    result = null;
    walkOneLevel = function(cb) {
      var commit1, commit2, commitHash, pushAncestors, visited, _i, _len, _ref2, _ref3;
      commit1 = walker1.queue.pop();
      commit2 = walker2.queue.pop();
      _ref2 = [[commit1, walker2.visited], [commit2, walker1.visited]];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        _ref3 = _ref2[_i], commitHash = _ref3[0], visited = _ref3[1];
        if (visited[commitHash] !== void 0) {
          result = {
            commit: commitHash,
            commit1Path: findWalkPath(commitHash, walker1.visited),
            commit2Path: findWalkPath(commitHash, walker2.visited)
          };
          return cb(null);
        }
      }
      pushAncestors = function(_arg, cb) {
        var commitHash, walker;
        commitHash = _arg[0], walker = _arg[1];
        return commitAncestors(commitHash, commitStore, function(err, ancestors) {
          var _j, _len1;
          for (_j = 0, _len1 = ancestors.length; _j < _len1; _j++) {
            each = ancestors[_j];
            walker.queue.push(each);
            if (!walker.visited[each]) {
              walker.visited[each] = commitHash;
            }
          }
          return cb();
        });
      };
      return async.forEach([[commit1, walker1], [commit2, walker2]], pushAncestors, cb);
    };
    condition = function() {
      return (result === null) && ((walker1.queue.length() > 0) || (walker2.queue.length() > 0));
    };
    return async.whilst(condition, walkOneLevel, function() {
      return cb(null, result);
    });
  };

  findCommonCommit = function(commit1, commit2, commitStore, cb) {
    return findCommonCommitWithPaths(commit1, commit2, commitStore, function(err, res) {
      if (res) {
        return cb(null, res.commit);
      } else {
        return cb(null);
      }
    });
  };

  findDiffWithPaths = function(tree1Hash, tree2Hash, treeStore, cb) {
    var readOrCreateNewTree;
    if (tree1Hash === tree2Hash) {
      return cb(null, {
        trees: [],
        values: []
      });
    }
    readOrCreateNewTree = function(hash, cb) {
      if (hash) {
        return treeStore.read(hash, cb);
      } else {
        return cb(null, new Tree());
      }
    };
    return async.map([tree1Hash, tree2Hash], readOrCreateNewTree, function(err, _arg) {
      var deletedData, diff, key, mapChildTree, tree1, tree2, updatedData, value;
      tree1 = _arg[0], tree2 = _arg[1];
      diff = {
        values: [],
        trees: [
          {
            path: [],
            value: tree2Hash ? tree2Hash : null
          }
        ]
      };
      updatedData = (function() {
        var _ref1, _results;
        _ref1 = tree2.childData;
        _results = [];
        for (key in _ref1) {
          value = _ref1[key];
          if (tree1.childData[key] !== value) {
            _results.push({
              path: [key],
              value: value
            });
          }
        }
        return _results;
      })();
      deletedData = (function() {
        var _results;
        _results = [];
        for (key in tree1.childData) {
          if (tree2.childData[key] === void 0) {
            _results.push({
              path: [key],
              value: null
            });
          }
        }
        return _results;
      })();
      diff.values = union(updatedData, deletedData);
      mapChildTree = function(diff, key, cb) {
        return findDiffWithPaths(tree1.childTrees[key], tree2.childTrees[key], treeStore, function(err, childDiff) {
          var prependPath;
          prependPath = function(pathHashs) {
            var path, _i, _len, _ref1, _results;
            _results = [];
            for (_i = 0, _len = pathHashs.length; _i < _len; _i++) {
              _ref1 = pathHashs[_i], path = _ref1.path, value = _ref1.value;
              _results.push({
                path: [key].concat(__slice.call(path)),
                value: value
              });
            }
            return _results;
          };
          return cb(null, {
            trees: union(diff.trees, prependPath(childDiff.trees)),
            values: union(diff.values, prependPath(childDiff.values))
          });
        });
      };
      return async.reduce(union(keys(tree1.childTrees), keys(tree2.childTrees)), diff, mapChildTree, cb);
    });
  };

  findDeltaDiff = function(tree1Hash, tree2Hash, treeStore, cb) {
    var readOrCreateNewTree;
    if (tree1Hash === tree2Hash) {
      return cb(null, {
        trees: [],
        values: []
      });
    }
    readOrCreateNewTree = function(hash, cb) {
      if (hash) {
        return treeStore.read(hash, cb);
      } else {
        return cb(null, new Tree());
      }
    };
    return async.map([tree1Hash, tree2Hash], readOrCreateNewTree, function(err, _arg) {
      var diff, key, mapChildTree, tree1, tree2, value;
      tree1 = _arg[0], tree2 = _arg[1];
      diff = {
        values: [],
        trees: tree2Hash ? [tree2Hash] : []
      };
      diff.values = (function() {
        var _ref1, _results;
        _ref1 = tree2.childData;
        _results = [];
        for (key in _ref1) {
          value = _ref1[key];
          if (tree1.childData[key] !== value) {
            _results.push(value);
          }
        }
        return _results;
      })();
      mapChildTree = function(diff, key, cb) {
        return findDeltaDiff(tree1.childTrees[key], tree2.childTrees[key], treeStore, function(err, childDiff) {
          return cb(null, {
            trees: union(diff.trees, childDiff.trees),
            values: union(diff.values, childDiff.values)
          });
        });
      };
      return async.reduce(union(keys(tree1.childTrees), keys(tree2.childTrees)), diff, mapChildTree, cb);
    });
  };

  mergeDiffs = function(oldDiff, newDiff) {
    if (!newDiff.commits) {
      newDiff.commits = [];
    }
    return {
      commits: union(oldDiff.commits, newDiff.commits),
      trees: union(oldDiff.trees, newDiff.trees),
      values: union(oldDiff.values, newDiff.values)
    };
  };

  findDelta = function(commonCommitHashs, toCommitHash, treeStore, commitStore, cb) {
    var diff;
    if (contains(commonCommitHashs, toCommitHash)) {
      return cb(null, {
        commits: [],
        trees: [],
        values: []
      });
    }
    diff = {
      commits: [toCommitHash],
      trees: [],
      values: []
    };
    return commitStore.read(toCommitHash, function(err, toCommit) {
      var mapAncestorDiffs;
      mapAncestorDiffs = function(ancestor, cb) {
        return commitStore.read(ancestor, function(err, _arg) {
          var tree;
          tree = _arg.tree;
          return findDeltaDiff(tree, toCommit.tree, treeStore, cb);
        });
      };
      return async.map(toCommit.ancestors, mapAncestorDiffs, function(err, ancestorDiffs) {
        var reduceFun;
        if (toCommit.ancestors.length === 1) {
          diff = mergeDiffs(diff, ancestorDiffs[0]);
          return findDelta(commonCommitHashs, toCommit.ancestors[0], treeStore, commitStore, function(err, ancestorDelta) {
            return cb(null, mergeDiffs(diff, ancestorDelta));
          });
        } else if (toCommit.ancestors.length === 0) {
          return findDeltaDiff(null, toCommit.tree, treeStore, function(err, deltaDiff) {
            return cb(null, mergeDiffs(diff, deltaDiff));
          });
        } else {
          diff = mergeDiffs(diff, {
            trees: intersection.apply(null, pluck(ancestorDiffs, 'trees')),
            values: intersection.apply(null, pluck(ancestorDiffs, 'values'))
          });
          reduceFun = function(diff, ancestor, cb) {
            var mapCommonCommit;
            mapCommonCommit = function(each, cb) {
              return findCommonCommit(ancestor, each, treeStore, cb);
            };
            return async.map(commonCommitHashs, mapCommonCommit, function(err, newCommonTreeHashs) {
              return findDelta(union(newCommonTreeHashs), ancestor, treeStore, commitStore, function(err, ancestorDelta) {
                return cb(null, mergeDiffs(diff, ancestorDelta));
              });
            });
          };
          return async.reduce(toCommit.ancestors, diff, reduceFun, cb);
        }
      });
    });
  };

  mergingCommit = function(commonTreeHash, tree1Hash, tree2Hash, strategy, treeStore) {
    var commonTree, conflict, each, mergeChildTrees, mergeData, newTree, tree1, tree2, _ref1;
    conflict = (commonTreeHash !== tree1Hash) && (commonTreeHash !== tree2Hash);
    if (!conflict) {
      if (tree1Hash === commonTreeHash) {
        return tree2Hash;
      } else {
        return tree1Hash;
      }
    } else {
      _ref1 = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = [commonTreeHash, tree1Hash, tree2Hash];
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          each = _ref1[_i];
          if (each) {
            _results.push(treeStore.read(each));
          } else {
            _results.push(new Tree());
          }
        }
        return _results;
      })(), commonTree = _ref1[0], tree1 = _ref1[1], tree2 = _ref1[2];
      newTree = new Tree;
      mergeData = function() {
        var commonData, data1, data2, key, _i, _len, _ref2, _results;
        _ref2 = union(keys(tree2.childData), keys(tree1.childData));
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          key = _ref2[_i];
          commonData = commonTree.childData[key];
          data1 = tree1.childData[key];
          data2 = tree2.childData[key];
          conflict = (commonData !== data1) && (commonData !== data2);
          if (conflict) {
            _results.push(newTree.childData[key] = strategy(key, data1, data2));
          } else {
            _results.push(newTree.childData[key] = data1 === commonData ? data2 : data1);
          }
        }
        return _results;
      };
      mergeChildTrees = function() {
        var key, _i, _len, _ref2, _results;
        _ref2 = union(keys(tree2.childTrees), keys(tree1.childTrees));
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          key = _ref2[_i];
          _results.push(newTree.childTrees[key] = mergingCommit(commonTree.childTrees[key], tree1.childTrees[key], tree2.childTrees[key], strategy, treeStore));
        }
        return _results;
      };
      mergeData();
      mergeChildTrees();
      return treeStore.write(newTree);
    }
  };

  Repository = (function() {

    function Repository(_arg) {
      var _ref1;
      _ref1 = _arg != null ? _arg : {}, this.treeStore = _ref1.treeStore, this.commitStore = _ref1.commitStore;
      if (!this.treeStore) {
        this.treeStore = contentAddressable();
      }
      if (!this.commitStore) {
        this.commitStore = contentAddressable();
      }
      this._treeStore = new Store(this.treeStore, Tree);
      this._commitStore = new Store(this.commitStore, Commit);
    }

    Repository.prototype.branch = function(treeHash) {
      return new Branch(this, treeHash);
    };

    Repository.prototype.commit = function(oldCommitHash, data, cb) {
      var obj;
      obj = this;
      return this._commitStore.read(oldCommitHash, function(err, oldCommit) {
        var oldTree, parsedData, path, value;
        oldTree = oldCommit ? oldCommit.tree : void 0;
        parsedData = (function() {
          var _results;
          _results = [];
          for (path in data) {
            value = data[path];
            _results.push({
              path: path.split('/').reverse(),
              value: value
            });
          }
          return _results;
        })();
        return commit(oldTree, parsedData, obj._treeStore, function(err, newTree) {
          var ancestors, newCommit;
          if (newTree === oldTree) {
            return cb(null, oldCommitHash);
          } else {
            ancestors = oldCommitHash ? [oldCommitHash] : [];
            newCommit = new Commit({
              ancestors: ancestors,
              tree: newTree
            });
            return obj._commitStore.write(newCommit, cb);
          }
        });
      });
    };

    Repository.prototype.treeAtPath = function(commitHash, path) {
      var tree;
      path = path === '' ? [] : path.split('/').reverse();
      tree = this._commitStore.read(commitHash).tree;
      return readTreeAtPath(tree, this._treeStore, path);
    };

    Repository.prototype.dataAtPath = function(commitHash, path, cb) {
      var obj;
      obj = this;
      path = path.split('/').reverse();
      return this._commitStore.read(commitHash, function(err, _arg) {
        var tree;
        tree = _arg.tree;
        return read(tree, obj._treeStore, path, cb);
      });
    };

    Repository.prototype.allPaths = function(commitHash) {
      var path, tree, value, _i, _len, _ref1, _ref2, _results;
      tree = this._commitStore.read(commitHash).tree;
      _ref1 = allPaths(tree, this._treeStore);
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        _ref2 = _ref1[_i], path = _ref2.path, value = _ref2.value;
        _results.push({
          path: path.join('/'),
          value: value
        });
      }
      return _results;
    };

    Repository.prototype.commonCommit = function(commit1, commit2, cb) {
      return findCommonCommit(commit1, commit2, this._commitStore, cb);
    };

    Repository.prototype.commonCommitWithPaths = function(commit1, commit2, cb) {
      return findCommonCommitWithPaths(commit1, commit2, this._commitStore, cb);
    };

    Repository.prototype.diff = function(commit1, commit2, cb) {
      var obj, readCommitTree;
      obj = this;
      readCommitTree = function(each, cb) {
        if (each) {
          return obj._commitStore.read(each, function(err, commitObj) {
            return cb(null, commitObj.tree);
          });
        } else {
          return cb(null);
        }
      };
      return async.map([commit1, commit2], readCommitTree, function(err, _arg) {
        var tree1, tree2;
        tree1 = _arg[0], tree2 = _arg[1];
        return findDiffWithPaths(tree1, tree2, obj._treeStore, function(err, diff) {
          var translatePaths;
          translatePaths = function(array) {
            var path, value, _i, _len, _ref1, _results;
            _results = [];
            for (_i = 0, _len = array.length; _i < _len; _i++) {
              _ref1 = array[_i], path = _ref1.path, value = _ref1.value;
              _results.push({
                path: path.join('/'),
                value: value
              });
            }
            return _results;
          };
          return cb(null, {
            trees: translatePaths(diff.trees),
            values: translatePaths(diff.values)
          });
        });
      });
    };

    Repository.prototype.deltaHashs = function(_arg, cb) {
      var deltaForEach, diff, from, obj, to;
      from = _arg.from, to = _arg.to;
      obj = this;
      diff = {
        commits: [],
        trees: [],
        values: []
      };
      deltaForEach = function(diff, toEach, cb) {
        return async.map(from, (function(fromEach, cb) {
          return obj.commonCommit(fromEach, toEach, cb);
        }), function(err, commonCommits) {
          commonCommits = _.without(commonCommits, void 0);
          return findDelta(commonCommits, toEach, obj._treeStore, obj._commitStore, function(err, newDelta) {
            return cb(null, mergeDiffs(diff, newDelta));
          });
        });
      };
      return async.reduce(to, diff, deltaForEach, cb);
    };

    Repository.prototype.deltaData = function(delta) {
      var each;
      return {
        commits: (function() {
          var _i, _len, _ref1, _results;
          _ref1 = delta.commits;
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            each = _ref1[_i];
            _results.push(this.commitStore.read(each));
          }
          return _results;
        }).call(this),
        trees: (function() {
          var _i, _len, _ref1, _results;
          _ref1 = delta.trees;
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            each = _ref1[_i];
            _results.push(this.treeStore.read(each));
          }
          return _results;
        }).call(this),
        values: delta.values
      };
    };

    Repository.prototype.merge = function(commit1, commit2, strategy) {
      var commonCommit, commonTree, each, newTree, obj, tree1, tree2, _ref1;
      obj = this;
      strategy = strategy ? strategy : function(path, value1Hash, value2Hash) {
        return value1Hash;
      };
      commonCommit = this.commonCommit(commit1, commit2);
      if (commit1 === commonCommit) {
        return commit2;
      } else if (commit2 === commonCommit) {
        return commit1;
      } else {
        _ref1 = (function() {
          var _i, _len, _ref1, _results;
          _ref1 = [commonCommit, commit1, commit2];
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            each = _ref1[_i];
            if (each) {
              _results.push(this._commitStore.read(each).tree);
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        }).call(this), commonTree = _ref1[0], tree1 = _ref1[1], tree2 = _ref1[2];
        newTree = mergingCommit(commonTree, tree1, tree2, strategy, this._treeStore);
        return this._commitStore.write(new Commit({
          ancestors: [commit1, commit2],
          tree: newTree
        }));
      }
    };

    return Repository;

  })();

  module.exports = Repository;

}).call(this);
