// Generated by CoffeeScript 1.3.3
(function() {
  var Branch, Queue, Repository, Tree, TreeStore, addKeyPrefix, allPaths, async, clone, commit, contains, contentAddressable, findCommonCommit, findCommonCommitWithPaths, findDelta, findDeltaDiff, findDiffWithPaths, findWalkPath, groupCurrentAndChildTreeData, intersection, keyValueStore, keys, mergeDiffs, mergingCommit, objectDiff, objectDiffObject, pluck, read, readTreeAtPath, treeAncestors, union, values, _, _ref,
    __slice = [].slice;

  async = require('async');

  _ = require('underscore');

  union = _.union, values = _.values, keys = _.keys, intersection = _.intersection, clone = _.clone, contains = _.contains, pluck = _.pluck;

  _ref = require('./utils'), objectDiff = _ref.objectDiff, objectDiffObject = _ref.objectDiffObject, addKeyPrefix = _ref.addKeyPrefix, Queue = _ref.Queue;

  Branch = require('./branch');

  TreeStore = require('./tree-store');

  contentAddressable = require('content-addressable').memory;

  keyValueStore = require('pluggable-store').memory;

  Tree = (function() {

    function Tree(_arg) {
      var ancestors, childData, childTrees, _ref1;
      _ref1 = _arg != null ? _arg : {}, ancestors = _ref1.ancestors, childTrees = _ref1.childTrees, childData = _ref1.childData;
      this.ancestors = ancestors ? ancestors : [];
      this.childTrees = childTrees ? childTrees : {};
      this.childData = childData ? childData : {};
    }

    return Tree;

  })();

  groupCurrentAndChildTreeData = function(data) {
    var childTreeData, currentTreeData, hash, key, path, _i, _len, _ref1;
    currentTreeData = {};
    childTreeData = {};
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      _ref1 = data[_i], path = _ref1.path, hash = _ref1.hash;
      key = path.pop();
      if (path.length === 0) {
        currentTreeData[key] = hash;
      } else {
        if (!childTreeData[key]) {
          childTreeData[key] = [];
        }
        childTreeData[key].push({
          path: path,
          hash: hash
        });
      }
    }
    return [currentTreeData, childTreeData];
  };

  commit = function(treeHash, data, treeStore) {
    var changedTree, childTreeData, currentTree, currentTreeData, hash, key, newChildTree, previousTree, _ref1;
    changedTree = false;
    currentTree = treeHash ? treeStore.read(treeHash) : new Tree();
    _ref1 = groupCurrentAndChildTreeData(data), currentTreeData = _ref1[0], childTreeData = _ref1[1];
    for (key in currentTreeData) {
      hash = currentTreeData[key];
      if (currentTree.childData[key] !== hash) {
        changedTree = true;
        if (hash) {
          currentTree.childData[key] = hash;
        } else {
          delete currentTree.childData[key];
        }
      }
    }
    for (key in childTreeData) {
      data = childTreeData[key];
      previousTree = currentTree.childTrees[key];
      newChildTree = commit(previousTree, data, treeStore);
      if (newChildTree !== previousTree) {
        changedTree = true;
        if (newChildTree) {
          currentTree.childTrees[key] = newChildTree;
        } else {
          delete currentTree.childTrees[key];
        }
      }
    }
    if ((_.size(currentTree.childTrees) > 0) || (_.size(currentTree.childData) > 0)) {
      if (changedTree) {
        if (treeHash) {
          currentTree.ancestors = [treeHash];
        }
        return treeStore.write(currentTree);
      } else {
        return treeHash;
      }
    }
  };

  readTreeAtPath = function(treeHash, treeStore, path) {
    var key, tree;
    tree = treeStore.read(treeHash);
    if (path.length === 0) {
      return tree;
    } else {
      key = path.pop();
      return readTreeAtPath(tree.childTrees[key], treeStore, path);
    }
  };

  read = function(treeHash, treeStore, path) {
    var key, tree;
    if (!treeHash) {
      return void 0;
    } else {
      tree = treeStore.read(treeHash);
      key = path.pop();
      if (path.length === 0) {
        return tree.childData[key];
      } else {
        return read(tree.childTrees[key], treeStore, path);
      }
    }
  };

  allPaths = function(treeHash, treeStore) {
    var childPaths, childTree, key, path, paths, res, tree, value, _ref1;
    tree = treeStore.read(treeHash);
    paths = [];
    _ref1 = tree.childTrees;
    for (key in _ref1) {
      childTree = _ref1[key];
      childPaths = allPaths(childTree, treeStore);
      res = (function() {
        var _i, _len, _ref2, _results;
        _results = [];
        for (_i = 0, _len = childPaths.length; _i < _len; _i++) {
          _ref2 = childPaths[_i], path = _ref2.path, value = _ref2.value;
          _results.push({
            path: [key].concat(__slice.call(path)),
            value: value
          });
        }
        return _results;
      })();
      paths = paths.concat(res);
    }
    return paths.concat((function() {
      var _ref2, _results;
      _ref2 = tree.childData;
      _results = [];
      for (key in _ref2) {
        value = _ref2[key];
        _results.push({
          path: [key],
          value: value
        });
      }
      return _results;
    })());
  };

  treeAncestors = function(treeHash, treeStore) {
    var tree;
    tree = treeStore.read(treeHash);
    if (tree) {
      return tree.ancestors;
    } else {
      return [];
    }
  };

  findWalkPath = function(tree, visited) {
    var arr;
    arr = [tree];
    while ((tree = visited[tree])) {
      arr.push(tree);
    }
    return arr;
  };

  findCommonCommitWithPaths = function(tree1Start, tree2Start, treeStore) {
    var ancestors, each, tree, tree1, tree2, visited, walker, walker1, walker2, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3, _ref4, _ref5;
    if ((!tree1Start) || (!tree2Start)) {
      return void 0;
    }
    _ref1 = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = [tree1Start, tree2Start];
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        each = _ref1[_i];
        walker = {
          queue: new Queue,
          visited: {}
        };
        walker.queue.push(each);
        walker.visited[each] = null;
        _results.push(walker);
      }
      return _results;
    })(), walker1 = _ref1[0], walker2 = _ref1[1];
    while ((tree1 = walker1.queue.pop()) || (tree2 = walker2.queue.pop())) {
      _ref2 = [[tree1, walker2.visited], [tree2, walker1.visited]];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        _ref3 = _ref2[_i], tree = _ref3[0], visited = _ref3[1];
        if (visited[tree] !== void 0) {
          return {
            tree: tree,
            tree1Path: findWalkPath(tree, walker1.visited),
            tree2Path: findWalkPath(tree, walker2.visited)
          };
        }
      }
      _ref4 = [[tree1, walker1], [tree2, walker2]];
      for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
        _ref5 = _ref4[_j], tree = _ref5[0], walker = _ref5[1];
        ancestors = treeAncestors(tree, treeStore);
        for (_k = 0, _len2 = ancestors.length; _k < _len2; _k++) {
          each = ancestors[_k];
          walker.queue.push(each);
          if (!walker.visited[each]) {
            walker.visited[each] = tree;
          }
        }
      }
    }
    return void 0;
  };

  findCommonCommit = function(tree1, tree2, treeStore) {
    var res;
    res = findCommonCommitWithPaths(tree1, tree2, treeStore);
    if (res) {
      return res.tree;
    }
  };

  findDiffWithPaths = function(tree1Hash, tree2Hash, treeStore) {
    var deletedData, diff, each, key, mapChildTree, tree1, tree2, updatedData, value, _ref1;
    if (tree1Hash === tree2Hash) {
      return {
        trees: [],
        data: []
      };
    }
    _ref1 = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = [tree1Hash, tree2Hash];
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        each = _ref1[_i];
        if (each) {
          _results.push(treeStore.read(each));
        } else {
          _results.push(new Tree());
        }
      }
      return _results;
    })(), tree1 = _ref1[0], tree2 = _ref1[1];
    diff = {
      data: [],
      trees: [
        {
          path: [],
          hash: tree2Hash ? tree2Hash : null
        }
      ]
    };
    updatedData = (function() {
      var _ref2, _results;
      _ref2 = tree2.childData;
      _results = [];
      for (key in _ref2) {
        value = _ref2[key];
        if (tree1.childData[key] !== value) {
          _results.push({
            path: [key],
            hash: value
          });
        }
      }
      return _results;
    })();
    deletedData = (function() {
      var _results;
      _results = [];
      for (key in tree1.childData) {
        if (tree2.childData[key] === void 0) {
          _results.push({
            path: [key],
            hash: null
          });
        }
      }
      return _results;
    })();
    diff.data = union(updatedData, deletedData);
    mapChildTree = function(diff, key) {
      var childDiff, prependPath;
      childDiff = findDiffWithPaths(tree1.childTrees[key], tree2.childTrees[key], treeStore);
      prependPath = function(pathHashs) {
        var hash, path, _i, _len, _ref2, _results;
        _results = [];
        for (_i = 0, _len = pathHashs.length; _i < _len; _i++) {
          _ref2 = pathHashs[_i], path = _ref2.path, hash = _ref2.hash;
          _results.push({
            path: [key].concat(__slice.call(path)),
            hash: hash
          });
        }
        return _results;
      };
      return {
        trees: union(diff.trees, prependPath(childDiff.trees)),
        data: union(diff.data, prependPath(childDiff.data))
      };
    };
    return union(keys(tree1.childTrees), keys(tree2.childTrees)).reduce(mapChildTree, diff);
  };

  mergeDiffs = function(oldDiff, newDiff) {
    return {
      trees: union(oldDiff.trees, newDiff.trees),
      data: union(oldDiff.data, newDiff.data)
    };
  };

  findDeltaDiff = function(tree1Hash, tree2Hash, treeStore) {
    var diff, each, key, mapChildTree, tree1, tree2, value, _ref1;
    if (tree1Hash === tree2Hash) {
      return {
        trees: [],
        data: []
      };
    }
    _ref1 = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = [tree1Hash, tree2Hash];
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        each = _ref1[_i];
        if (each) {
          _results.push(treeStore.read(each));
        } else {
          _results.push(new Tree());
        }
      }
      return _results;
    })(), tree1 = _ref1[0], tree2 = _ref1[1];
    diff = {
      data: [],
      trees: tree2Hash ? [tree2Hash] : []
    };
    diff.data = (function() {
      var _ref2, _results;
      _ref2 = tree2.childData;
      _results = [];
      for (key in _ref2) {
        value = _ref2[key];
        if (tree1.childData[key] !== value) {
          _results.push(value);
        }
      }
      return _results;
    })();
    mapChildTree = function(diff, key) {
      var childDiff;
      childDiff = findDeltaDiff(tree1.childTrees[key], tree2.childTrees[key], treeStore);
      return mergeDiffs(diff, childDiff);
    };
    return union(keys(tree1.childTrees), keys(tree2.childTrees)).reduce(mapChildTree, diff);
  };

  findDelta = function(commonTreeHashs, toTreeHash, treeStore) {
    var ancestor, ancestorDiffs, diff, reduceFun, toTree;
    if (contains(commonTreeHashs, toTreeHash)) {
      return {
        trees: [],
        data: []
      };
    }
    toTree = treeStore.read(toTreeHash);
    ancestorDiffs = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = toTree.ancestors;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        ancestor = _ref1[_i];
        _results.push(findDeltaDiff(ancestor, toTreeHash, treeStore));
      }
      return _results;
    })();
    if (toTree.ancestors.length === 1) {
      return mergeDiffs(ancestorDiffs[0], findDelta(commonTreeHashs, toTree.ancestors[0], treeStore));
    } else if (toTree.ancestors.length === 0) {
      return findDeltaDiff(null, toTreeHash, treeStore);
    } else {
      diff = {
        trees: union.apply(null, pluck(ancestorDiffs, 'trees')),
        data: intersection.apply(null, pluck(ancestorDiffs, 'data'))
      };
      reduceFun = function(diff, ancestor) {
        var each, newCommonTreeHashs;
        newCommonTreeHashs = union((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = commonTreeHashs.length; _i < _len; _i++) {
            each = commonTreeHashs[_i];
            _results.push(findCommonCommit(ancestor, each, treeStore));
          }
          return _results;
        })());
        return mergeDiffs(diff, findDelta(newCommonTreeHashs, ancestor, treeStore));
      };
      return toTree.ancestors.reduce(reduceFun, diff);
    }
  };

  mergingCommit = function(commonTreeHash, tree1Hash, tree2Hash, strategy, treeStore) {
    var ancestors, commonTree, conflict, each, mergeChildTrees, mergeData, newTree, tree1, tree2, _ref1;
    conflict = (commonTreeHash !== tree1Hash) && (commonTreeHash !== tree2Hash);
    if (!conflict) {
      if (tree1Hash === commonTreeHash) {
        return tree2Hash;
      } else {
        return tree1Hash;
      }
    } else {
      _ref1 = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = [commonTreeHash, tree1Hash, tree2Hash];
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          each = _ref1[_i];
          if (each) {
            _results.push(treeStore.read(each));
          } else {
            _results.push(new Tree());
          }
        }
        return _results;
      })(), commonTree = _ref1[0], tree1 = _ref1[1], tree2 = _ref1[2];
      ancestors = (function() {
        var _i, _len, _ref2, _results;
        _ref2 = [tree1Hash, tree2Hash];
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          each = _ref2[_i];
          if (each) {
            _results.push(each);
          }
        }
        return _results;
      })();
      newTree = new Tree({
        ancestors: ancestors
      });
      mergeData = function() {
        var commonData, data1, data2, key, _i, _len, _ref2, _results;
        _ref2 = union(keys(tree2.childData), keys(tree1.childData));
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          key = _ref2[_i];
          commonData = commonTree.childData[key];
          data1 = tree1.childData[key];
          data2 = tree2.childData[key];
          conflict = (commonData !== data1) && (commonData !== data2);
          if (conflict) {
            _results.push(newTree.childData[key] = strategy(key, data1, data2));
          } else {
            _results.push(newTree.childData[key] = data1 === commonData ? data2 : data1);
          }
        }
        return _results;
      };
      mergeChildTrees = function() {
        var key, _i, _len, _ref2, _results;
        _ref2 = keys(tree2.childTrees);
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          key = _ref2[_i];
          _results.push(newTree.childTrees[key] = mergingCommit(commonTree.childTrees[key], tree1.childTrees[key], tree2.childTrees[key], strategy, treeStore));
        }
        return _results;
      };
      mergeData();
      mergeChildTrees();
      return treeStore.write(newTree);
    }
  };

  Repository = (function() {

    function Repository(_arg) {
      this.treeStore = (_arg != null ? _arg : {}).treeStore;
      if (!this.treeStore) {
        this.treeStore = contentAddressable();
      }
      this._treeStore = new TreeStore(this.treeStore);
    }

    Repository.prototype.branch = function(treeHash) {
      return new Branch(this, treeHash);
    };

    Repository.prototype.commit = function(oldTree, data) {
      var hash, parsedData, path;
      parsedData = (function() {
        var _results;
        _results = [];
        for (path in data) {
          hash = data[path];
          _results.push({
            path: path.split('/').reverse(),
            hash: hash
          });
        }
        return _results;
      })();
      return commit(oldTree, parsedData, this._treeStore);
    };

    Repository.prototype.treeAtPath = function(tree, path) {
      path = path === '' ? [] : path.split('/').reverse();
      return readTreeAtPath(tree, this._treeStore, path);
    };

    Repository.prototype.dataAtPath = function(tree, path) {
      path = path.split('/').reverse();
      return read(tree, this._treeStore, path);
    };

    Repository.prototype.allPaths = function(treeHash) {
      var path, value, _i, _len, _ref1, _ref2, _results;
      _ref1 = allPaths(treeHash, this._treeStore);
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        _ref2 = _ref1[_i], path = _ref2.path, value = _ref2.value;
        _results.push({
          path: path.join('/'),
          value: value
        });
      }
      return _results;
    };

    Repository.prototype.commonCommit = function(tree1, tree2) {
      return findCommonCommit(tree1, tree2, this._treeStore);
    };

    Repository.prototype.commonCommitWithPaths = function(tree1, tree2) {
      return findCommonCommitWithPaths(tree1, tree2, this._treeStore);
    };

    Repository.prototype.diff = function(tree1, tree2) {
      var diff, translatePaths;
      diff = findDiffWithPaths(tree1, tree2, this._treeStore);
      translatePaths = function(array) {
        var hash, path, _i, _len, _ref1, _results;
        _results = [];
        for (_i = 0, _len = array.length; _i < _len; _i++) {
          _ref1 = array[_i], path = _ref1.path, hash = _ref1.hash;
          _results.push({
            path: path.join('/'),
            hash: hash
          });
        }
        return _results;
      };
      return {
        trees: translatePaths(diff.trees),
        data: translatePaths(diff.data)
      };
    };

    Repository.prototype.deltaHashs = function(_arg) {
      var commonTrees, diff, from, fromEach, to, toEach, _i, _len;
      from = _arg.from, to = _arg.to;
      diff = {
        trees: [],
        data: []
      };
      for (_i = 0, _len = to.length; _i < _len; _i++) {
        toEach = to[_i];
        commonTrees = (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = from.length; _j < _len1; _j++) {
            fromEach = from[_j];
            _results.push(this.commonCommit(fromEach, toEach));
          }
          return _results;
        }).call(this);
        diff = mergeDiffs(diff, findDelta(commonTrees, toEach, this._treeStore));
      }
      return diff;
    };

    Repository.prototype.deltaData = function(delta) {
      var each;
      return {
        trees: (function() {
          var _i, _len, _ref1, _results;
          _ref1 = delta.trees;
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            each = _ref1[_i];
            _results.push(this.treeStore.read(each));
          }
          return _results;
        }).call(this),
        data: delta.data
      };
    };

    Repository.prototype.merge = function(tree1, tree2, strategy) {
      var commonTree, obj;
      obj = this;
      strategy = strategy ? strategy : function(path, value1Hash, value2Hash) {
        return value1Hash;
      };
      commonTree = this.commonCommit(tree1, tree2);
      if (tree1 === commonTree) {
        return tree2;
      } else if (tree2 === commonTree) {
        return tree1;
      } else {
        return mergingCommit(commonTree, tree1, tree2, strategy, this._treeStore);
      }
    };

    return Repository;

  })();

  module.exports = Repository;

}).call(this);
