// Generated by CoffeeScript 1.3.3
(function() {
  var Branch, Repository, Tree, addKeyPrefix, async, clone, commit, findCommonCommit, findDiff, findDiffSince, findDiffWithPaths, intersection, keys, mergingCommit, objectDiff, objectDiffObject, read, readTreeAtPath, splitCurrentAndChildTreeData, treeParents, treesParents, union, values, _, _ref;

  async = require('async');

  _ = require('underscore');

  union = _.union, values = _.values, keys = _.keys, intersection = _.intersection, clone = _.clone;

  _ref = require('./utils'), objectDiff = _ref.objectDiff, objectDiffObject = _ref.objectDiffObject, addKeyPrefix = _ref.addKeyPrefix;

  Branch = require('./branch');

  Tree = (function() {

    function Tree(_arg) {
      var ancestors, childData, childTrees, _ref1;
      _ref1 = _arg != null ? _arg : {}, ancestors = _ref1.ancestors, childTrees = _ref1.childTrees, childData = _ref1.childData;
      this.ancestors = ancestors ? ancestors : [];
      this.childTrees = childTrees ? childTrees : {};
      this.childData = childData ? childData : {};
    }

    return Tree;

  })();

  splitCurrentAndChildTreeData = function(data) {
    var childTreeData, currentTreeData, hash, key, path, _i, _len, _ref1;
    currentTreeData = {};
    childTreeData = {};
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      _ref1 = data[_i], path = _ref1.path, hash = _ref1.hash;
      key = path.pop();
      if (path.length === 0) {
        currentTreeData[key] = hash;
      } else {
        if (!childTreeData[key]) {
          childTreeData[key] = [];
        }
        childTreeData[key].push({
          path: path,
          hash: hash
        });
      }
    }
    return [currentTreeData, childTreeData];
  };

  commit = function(treeHash, data, treeStore) {
    var childTreeData, currentTree, currentTreeData, hash, key, newChildTree, previousTree, tree, _ref1;
    currentTree = treeHash ? (tree = treeStore.read(treeHash), new Tree({
      childData: clone(tree.childData),
      childTrees: clone(tree.childTrees),
      ancestors: [treeHash]
    })) : new Tree();
    _ref1 = splitCurrentAndChildTreeData(data), currentTreeData = _ref1[0], childTreeData = _ref1[1];
    for (key in currentTreeData) {
      hash = currentTreeData[key];
      if (hash) {
        currentTree.childData[key] = hash;
      } else {
        delete currentTree.childData[key];
      }
    }
    for (key in childTreeData) {
      data = childTreeData[key];
      previousTree = currentTree.childTrees[key];
      newChildTree = commit(previousTree, data, treeStore);
      if (newChildTree) {
        currentTree.childTrees[key] = newChildTree;
      } else {
        delete currentTree.childTrees[key];
      }
    }
    if ((_.size(currentTree.childTrees) > 0) || (_.size(currentTree.childData) > 0)) {
      return treeStore.write(currentTree);
    }
  };

  readTreeAtPath = function(treeHash, treeStore, path) {
    var key, tree;
    tree = treeStore.read(treeHash);
    if (path.length === 0) {
      return tree;
    } else {
      key = path.pop();
      return readTreeAtPath(tree.childTrees[key], treeStore, path);
    }
  };

  read = function(treeHash, treeStore, path) {
    var key, tree;
    if (!treeHash) {
      return void 0;
    } else {
      tree = treeStore.read(treeHash);
      key = path.pop();
      if (path.length === 0) {
        return tree.childData[key];
      } else {
        return read(tree.childTrees[key], treeStore, path);
      }
    }
  };

  treeParents = function(treeHash, treeStore) {
    return treeStore.read(treeHash).ancestors;
  };

  treesParents = function(treeStore) {
    return function(trees) {
      var each;
      return _.flatten((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = trees.length; _i < _len; _i++) {
          each = trees[_i];
          _results.push(treeParents(each, treeStore));
        }
        return _results;
      })());
    };
  };

  findCommonCommit = function(trees1, trees2, treeStore) {
    var each, merge, trees1Parents, trees2Parents, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4;
    if ((trees1.current.length === 0) && (trees2.current.length === 0)) {
      return void 0;
    }
    _ref1 = [[trees1, trees2], [trees2, trees1]];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      _ref2 = _ref1[_i], trees1 = _ref2[0], trees2 = _ref2[1];
      _ref3 = trees1.current;
      for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
        each = _ref3[_j];
        if (_.contains(trees2.visited.concat(trees2.current), each)) {
          return each;
        }
      }
    }
    _ref4 = [trees1.current, trees2.current].map(treesParents(treeStore)), trees1Parents = _ref4[0], trees2Parents = _ref4[1];
    merge = function(oldTrees, newParents) {
      return {
        current: newParents,
        visited: oldTrees.visited.concat(oldTrees.current)
      };
    };
    return findCommonCommit(merge(trees1, trees1Parents), merge(trees2, trees2Parents), treeStore);
  };

  findDiffWithPaths = function(tree1Hash, tree2Hash, treeStore) {
    var diff, each, mapChildTree, tree1, tree2, _ref1;
    if (tree1Hash === tree2Hash) {
      return {
        trees: {},
        data: {}
      };
    }
    _ref1 = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = [tree1Hash, tree2Hash];
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        each = _ref1[_i];
        if (each) {
          _results.push(treeStore.read(each));
        } else {
          _results.push(new Tree());
        }
      }
      return _results;
    })(), tree1 = _ref1[0], tree2 = _ref1[1];
    diff = {
      data: {},
      trees: {}
    };
    diff.trees = objectDiffObject(tree1.childTrees, tree2.childTrees);
    diff.data = objectDiffObject(tree1.childData, tree2.childData);
    mapChildTree = function(diff, key) {
      var childDiff, _i, _len, _ref2;
      childDiff = findDiffWithPaths(tree1.childTrees[key], tree2.childTrees[key], treeStore);
      _ref2 = [childDiff.data, childDiff.trees];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        each = _ref2[_i];
        addKeyPrefix(each, key + '/');
      }
      return {
        trees: _.extend(diff.trees, childDiff.trees),
        data: _.extend(diff.data, childDiff.data)
      };
    };
    return _.keys(diff.trees).reduce(mapChildTree, diff);
  };

  findDiff = function(tree1Hash, tree2Hash, store) {
    var res;
    res = findDiffWithPaths(tree1Hash, tree2Hash, store);
    return {
      trees: values(res.trees),
      data: values(res.data)
    };
  };

  findDiffSince = function(positions, oldTrees, treeStore) {
    var mergeDiff, reduceFun;
    positions = _.difference(positions, oldTrees);
    oldTrees = _.difference(oldTrees, positions);
    if ((oldTrees.length === 0) || (positions.length === 0)) {
      return {
        trees: [],
        data: []
      };
    } else {
      mergeDiff = function(diff, newDiff) {
        return {
          trees: union(diff.trees, newDiff.trees),
          data: union(diff.data, newDiff.data)
        };
      };
      reduceFun = function(diff, eachPosition) {
        var ancestors, parentDiffReduceFun;
        ancestors = treeParents(eachPosition, treeStore);
        if (ancestors.length > 0) {
          parentDiffReduceFun = function(diff, eachParent) {
            return mergeDiff(diff, findDiff(eachParent, eachPosition, treeStore));
          };
          diff = ancestors.reduce(parentDiffReduceFun, diff);
          return mergeDiff(diff, findDiffSince(ancestors, oldTrees, treeStore));
        } else {
          return mergeDiff(diff, findDiff(null, eachPosition, treeStore));
        }
      };
      return positions.reduce(reduceFun, {
        trees: [],
        data: []
      });
    }
  };

  mergingCommit = function(commonTreeHash, tree1Hash, tree2Hash, strategy, treeStore) {
    var ancestors, commonTree, conflict, each, mergeChildTrees, mergeData, newTree, tree1, tree2, _ref1;
    conflict = (commonTreeHash !== tree1Hash) && (commonTreeHash !== tree2Hash);
    if (!conflict) {
      if (tree1Hash === commonTreeHash) {
        return tree2Hash;
      } else {
        return tree1Hash;
      }
    } else {
      _ref1 = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = [commonTreeHash, tree1Hash, tree2Hash];
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          each = _ref1[_i];
          _results.push(treeStore.read(each));
        }
        return _results;
      })(), commonTree = _ref1[0], tree1 = _ref1[1], tree2 = _ref1[2];
      commonTree = commonTree ? commonTree : new Tree();
      tree1 = tree1 ? tree1 : new Tree();
      tree2 = tree2 ? tree2 : new Tree();
      ancestors = (function() {
        var _i, _len, _ref2, _results;
        _ref2 = [tree1Hash, tree2Hash];
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          each = _ref2[_i];
          if (each) {
            _results.push(each);
          }
        }
        return _results;
      })();
      newTree = new Tree({
        ancestors: ancestors
      });
      mergeData = function() {
        var commonData, data1, data2, key, _i, _len, _ref2, _results;
        _ref2 = union(keys(tree2.childData), keys(tree1.childData));
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          key = _ref2[_i];
          commonData = commonTree.childData[key];
          data1 = tree1.childData[key];
          data2 = tree2.childData[key];
          conflict = (commonData !== data1) && (commonData !== data2);
          if (conflict) {
            _results.push(newTree.childData[key] = strategy(key, data1, data2));
          } else {
            _results.push(newTree.childData[key] = data1 === commonData ? data2 : data1);
          }
        }
        return _results;
      };
      mergeChildTrees = function() {
        var key, _i, _len, _ref2, _results;
        _ref2 = keys(tree2.childTrees);
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          key = _ref2[_i];
          _results.push(newTree.childTrees[key] = mergingCommit(commonTree.childTrees[key], tree1.childTrees[key], tree2.childTrees[key], strategy, treeStore));
        }
        return _results;
      };
      mergeData();
      mergeChildTrees();
      return treeStore.write(newTree);
    }
  };

  Repository = (function() {

    function Repository(treeStore) {
      this.treeStore = treeStore;
    }

    Repository.prototype.branch = function(treeHash) {
      return new Branch(this, treeHash);
    };

    Repository.prototype.commit = function(oldTree, data) {
      var hash, parsedData, path;
      parsedData = (function() {
        var _results;
        _results = [];
        for (path in data) {
          hash = data[path];
          _results.push({
            path: path.split('/').reverse(),
            hash: hash
          });
        }
        return _results;
      })();
      return commit(oldTree, parsedData, this.treeStore);
    };

    Repository.prototype.treeAtPath = function(tree, path) {
      path = path === '' ? [] : path.split('/').reverse();
      return readTreeAtPath(tree, this.treeStore, path);
    };

    Repository.prototype.dataAtPath = function(tree, path) {
      path = path.split('/').reverse();
      return read(tree, this.treeStore, path);
    };

    Repository.prototype.commonCommit = function(tree1, tree2) {
      var each, trees1, trees2, _ref1;
      _ref1 = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = [tree1, tree2];
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          each = _ref1[_i];
          _results.push({
            current: [each],
            visited: []
          });
        }
        return _results;
      })(), trees1 = _ref1[0], trees2 = _ref1[1];
      return findCommonCommit(trees1, trees2, this.treeStore);
    };

    Repository.prototype.diff = function(tree1, tree2) {
      return findDiffWithPaths(tree1, tree2, this.treeStore);
    };

    Repository.prototype.diffSince = function(trees1, trees2) {
      return findDiffSince(trees1, trees2, this.treeStore);
    };

    Repository.prototype.merge = function(tree1, tree2, strategy) {
      var commonTree, obj;
      obj = this;
      commonTree = this.commonCommit(tree1, tree2);
      if (tree1 === commonTree) {
        return tree2;
      } else if (tree2 === commonTree) {
        return tree1;
      } else {
        return mergingCommit(commonTree, tree1, tree2, strategy, this.treeStore);
      }
    };

    return Repository;

  })();

  module.exports = Repository;

}).call(this);
